| Document Number: | d2912r0            |
| ---------------- | ------------------ |
| Date:            | 2023-06-13         |
| Target:          | SG1, LEWG          |
| Reply to:        | gorn@microsoft.com |

# d2912r0: Concurrent queues and sender/receivers

This paper explores extending interface of Buffered Queue (https://wg21.link/p1958r0) with async APIs
conforming to Sender/Receiver model according to https://wg21.link/p2300. It also makes stylistic API
changes to be more consistent with existent library facilities.

Additionally, we report on implementation experience (https://github.com/GorNishanov/conqueue)
addressing the concern that supporting
both synchronous and asynchronous push/pop in the same queue is a challenge (https://wg21.link/p2882r0).
The answer based on the implementation is that it is no challenge at all.

## Changes to buffer_queue

By following an example of `std::future`, enum `queue_op_status` was renamed to `conqueue_errc` and we
introduced an exception `conqueue_error` that will be thrown to carry the `conqueue_errc`.

```c++
enum class conqueue_errc { success = 0, empty, full, closed };
class conqueue_error : runtime_exception { ... };
... make_error_code, make_error_condition, conqueue_category, ...
```

The member functions `wait_pop` and `wait_push` were used as non-throwing versions of a blocking `pop` and `push`. By analogy with how
`<filesystem>` deals with this case, we restyled them as follows:

```c++
T pop(); // used to be pop_value
std::optional<T> pop(std::error_code &ec); // used to be wait_pop
std::optional<T> try_pop(std::error_code &ec);
```

```c++
void push(const T& x);
bool push(const T& x, error_code &ec); // used to be wait_push
bool try_push(const T& x, error_code &ec);

void push(T&& x);
bool push(T&& x, error_code &ec); // used to be wait_push
bool try_push(T&& x, error_code &ec);
```

Finally, to support async push and pop, we added

```c++
sender auto async_push(T x) noexcept(is_nothrow_move_constructible_v<T>);
sender auto async_pop() noexcept;
```

Note that async versions do not have `const T&` and `T&&` flavors,
since the handling ot the value may occur later on a different thread
the move of the value is required.

Based on usage experience, we can consider adding asynchronous equivalents of
other flavors of push and pop as needed.

## Implementation experience

A demonstration implementation is available in https://github.com/GorNishanov/conqueue.

An implementation only requires some kind of
critical section to be able to
change several related values atomically.
For example, spin lock is sufficient.

Additionally, to implement blocking for
synchronous push and pop, it is sufficient to use
C++20's `std::atomic_flag` wait facilities.

The highlights of one possible implementation are:

```c++
class buffer_queue {
  ...
private:
  std::mutex mutex; // or spin lock of some sort
  detail::ring_buffer buffer;
  // If the queue is empty, waiters are the readers.
  // If the queue is full, waiters are the writers.
  detail::intrusive_queue<&waiter_base::next> waiters;
  bool closed{};
};
```

Common base for both synchronous and asynchronous waiters stores:

```c++
struct waiter_base {
  waiter_base* next{};
  // For push case, we store the pointer to the value to be pushed.
  // For pop case, we store the value poped from the queue.
  variant<monostate, conqueue_errc, T, T*> value;
  void (*complete)(waiter_base*) noexcept;
};
```

And a concrete implementation for a synchronous waiter:

```c++
template <typename T> struct buffer_queue<T>::blocking_waiter : waiter_base {
  std::atomic_flag flag;

  blocking_waiter() noexcept {
    this->complete = [](waiter_base* w) noexcept {
      auto *self = static_cast<blocking_waiter*>(w);
      // Notifying sync waiter.
      self->flag.test_and_set();
      self->flag.notify_one();
    };
  }

  blocking_waiter(T& x) noexcept : blocking_waiter() {
    this->value = std::addressof(x);
  }

  void wait() noexcept { flag.wait(false); }
};
```

Sender/receiver implementation is a bit more involved (as usual with sender/receivers unrelated to the task at hand), so
here we are only showing the completion routine:

```c++
this->complete = [](waiter_base* w) noexcept {
  auto* self = static_cast<operation*>(w);
  if (auto* errc = get_if<conqueue_errc>(&self->value))
    stdexec::set_error((Receiver&&)self->receiver,
                        make_exception_ptr(conqueue_error(*errc)));
  else
    stdexec::set_value((Receiver&&)self->receiver);
};
```

Processing of the waiters is performed uniformly by interacting with waiter_base by
setting or reading error or value from the variant and invoking `complete` to resume the
sender or synchronous waiter. Having the queue support both synchronous and asynchronous APIs does not present a challenge.

## T pop() vs void pop(T&)

In the original paper [buffer_queue paper](https://wg21.link/p1958r0), the pop function
had signature `T pop_value()`. Subsequently, it was changed to `void pop(T&)` due to
concern about the problem of loosing elements.

Unlike STL's combinations of `void pop()` and `T& front()` that are possible for synchronous cases, such a solution does not work for concurrent queues, where we
cannot observe the value before popping it from the queue.

Comparing `T pop()` and `void pop(T&)` we believe that they are equivalent from
exception safety standpoint and `T pop()` wins on ergonomics of usage.

Naming wise, we chose `T pop()` rather than `T pop_value()` for consistency with the rest
of the APIs and due to `[[noexcept]]` guarding against misuse (thus if a user imagined that pop API is `void pop()` by analogy with `std::stack`, for example, a compiler error
will quickly bring them to their senses.

## try_push(T&&) vs try_push(T&&, T&)

In the original buffer queue paper [[p1958r0](https://wg21.link/p1958r0)], the try_push was:

```c++
queue_op_status try_push(Value&& x);
```

in the later paper [[p0260r5](https://wg21.link/p0260r5)], it was changed to:

```c++
queue_op_status try_push(Value&& x, Value& x);
```

with the rule:

> If the queue is full or closed, return the respective status and move the element into the second parameter. Otherwise, push the element onto the queue and return `queue_op_status::success`.

The rationale is likely was to have an ability not
to lose a temporary value if push operation did not succeed.

It seems that it is possible in both versions:

```c++
T x = get_something();
if (try_push(std::move(x))) ...
```

With two parameter version:

```c++
T x;
if (try_push(get_something(), x)) ...
```

Ergonomically they are roughly identical. API is slightly simpler with one argument version, therefore, we reverted to original one argument version.

## Exploring alternative APIs shapes

In this section we explore replacing the APIs that take std::error_code
parameter with expected returning one.

# Encoding expected variant with std::nothrow parameter

To distinguish between throwing and expected returning flavors, we use
std::nothrow_t parameter for disambiguation.

```c++
void push(const T&);
bool push(const T&, error_code& ec);
  vs
void push(const T&);
auto push(const T&, nothrow_t) -> expected<void, conqueue_errc>;
```

<table>
  <tr>
    <th>non-throwing: status-quo</th>
    <th>non-throwing: expected with nothrow</th>
  </tr>
  <tr>
    <td>
<pre>
std::error_code ec;
if (q.push(5, ec))
  return;
println("got {}", ec);
</pre>
    </td>
    <td>
<pre>
if (auto result = q.push(5, nothrow))
  return;
else
  println("got {}", result.error());
</pre>
    </td>
  </tr>
</table>

Another alternative suggested to us by some LEWG members
to eliminate the throwing version altogether and
replace with the expected returning only and we explore
this alternative in the next section.

# Status quo vs only expected based APIs

```c++
void push(const T&);
bool push(const T&, error_code& ec);
  vs
auto push(const T&) -> expected<void, conqueue_errc>;
```

<table>
  <tr>
    <th>non-throwing: status-quo</th>
    <th>non-throwing: expected only</th>
  </tr>
  <tr>
    <td>
<pre>
std::error_code ec;
if (q.push(5, ec))
  return;
println("got {}", ec);
</pre>
    </td>
    <td>
<pre>
if (auto result = q.push(5))
  return;
else
  println("got {}", result.error());
</pre>
    </td>
  </tr>
</table>

<table>
  <tr>
    <th>throwing: status quo</th>
    <th>throwing: expected only</th>
  </tr>
  <tr>
    <td>
<pre>
q.push(5);
  ...
catch(const conqueue_error& e)
</pre>
    </td>
    <td>
<pre>
q.push(5).or_else([](auto code) {
  throw conqueue_error(code);
});
  ...
catch(const conqueue_error& e)
</pre>
    </td>
  </tr>
</table>

<table>
  <tr>
    <th>throwing: status quo</th>
    <th>throwing: expected only (does not match status quo)</th>
  </tr>
  <tr>
    <td>
<pre>q.push(5);
  ...
catch(const conqueue_error& e)
</pre>
    </td>
    <td>
<pre>
q.push(5).value();
...
catch(const 
   bad_expected_access&lt;conqueue_errc&gt;& e) 
</pre>
    </td>
  </tr>
</table>

This alternative disfavors an exception throwing alternative and breaks with
the interface of `vector`, `stack` and other containers and
we consider this to be an inferior to the alternative offered in the previous section.

# Protection against consumption of values

While in our paper we suggested to follow the precedent of `try_emplace`
that guarantees that:

> If the map already contains an element whose key is equivalent to k, *this and args... are unchanged.

We recommend to follow `try_emplace` example in this regard as we do not envision
that providing this guarantee for the `buffer_queue` will be a burden for the implementors.

Nevertheless, we will explore in this section alternative API shapes:

```c++
bool try_push(T&& x, error_code& ec); or
auto try_push(T&& x, nothrow_t) -> expected<void, conqueue_errc>;

vs

auto try_push(T&& x, nothrow_t) -> expected<void, std::pair<T, conqueue_errc>>
```

<table>
  <tr>
    <th>unchanged guaranteed</th>
    <th>return back</th>
  </tr>
  <tr>
    <td>
<pre>
T val = get_value();
if (auto result = q.try_push(std::move(val)))
  return;
else
  println("failed {}, value {}", 
     result.error(), val);
</pre>
    </td>
    <td>
<pre>
if (auto result = q.try_push(get_value()))
   return;
else
  println("failed {}, value {}", 
     result.error().second,
     result.error().first);
</pre>
    </td>
  </tr>
</table>

Returning back the value, impose a burden on the user and
forces even more awkward catch clauses if bad_unexpected_access is thrown
in response to `expected<T>::value()` if the expected stores error,
since now error encodes the value as well.

Staying with guarantees similar to `try_emplace` remains our 
preferred alternative.

## linters and coding guidelines

There is another consideration brought up by LEWG is that 
clang-tidy warns on use after std::move. Luckily, clang-tidy recognizes
try_emplace being special and have special comment in the documentation:

https://clang.llvm.org/extra/clang-tidy/checks/bugprone/use-after-move.html#move

> There is one special case: A call to std::move inside a try_emplace call is conservatively assumed not to move. This is to avoid spurious warnings, as the check has no way to reason about the bool returned by try_emplace.

For C++26, clang-tidy will need to be updated to include relevant buffer_queue APIs that do not consume the value on failure.

### Coding Guidelines

Andreas Weis shared that upcoming Misra C++202x will be having a rule that bans use after move.

C++ Core Guidelines also has a rule [ES.56](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope) that 

> Usually, a std::move() is used as an argument to a && parameter. And after you do that, assume the object has been moved from (see C.64) and donâ€™t read its state again until you first set it to a new value.

We may choose to update the guidelines to carve an exception to APIs like `try_emplace` rather
than pessimizing `try_` API requiring incurring a copy-construction as opposed to a promise
not to touch the `T&&` arguments on failure.

# Other APIs

Assuming that we are restyling non-throwing versions
of the APIs along the lines that takes `std::nothrow` for disambiguation only,
and follow the precedent of `try_emplace` with regard to
not consuming `T&&` values on failure to push, the APIs will look like:

```c++
void push(const T&);
void push(T&&);

expected<void, conqueue_errc> push(const T&, nothrow_t);
expected<void, conqueue_errc> push(T&&, nothrow_t);

expected<void, conqueue_errc> try_push(const T&);
expected<void, conqueue_errc> try_push(T&&);

T pop();
expected<T, conqueue_errc> pop(nothrow_t);
expected<T, conqueue_errc> try_pop();
```
If the policy of LEWG would be to always add nothrow_t argument to `std::expected`
returning APIs, `try_` versions will become:

```c++
expected<void, conqueue_errc> try_push(const T&, nothrow_t);
expected<void, conqueue_errc> try_push(T&&, nothrow_t);
expected<T, conqueue_errc> try_pop(nothrow_t);
```
## References

1. [p1958r0: C++ Concurrent Buffer Queue](https://wg21.link/p1958r0)
2. [p0260r5: A proposal to add a concurrent queue
   to the standard library](https://wg21.link/p0260r5)
3. [p2882r0: An Event Model for C++ Executors](https://wg21.link/p2882r0)
4. [p2300r7: std::execution](https://wg21.link/p2300r7)
