<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
  "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<style type="text/css">

body { color: #000000; background-color: #FFFFFF; }
del { text-decoration: line-through; color: #8B0040; }
ins { text-decoration: underline; color: #005100; }

p.example { margin-left: 2em; }
pre.example { margin-left: 2em; }
div.example { margin-left: 2em; }

code.extract { background-color: #F5F6A2; }
pre.extract { margin-left: 2em; background-color: #F5F6A2;
  border: 1px solid #E1E28E; }

p.function { }
.attribute { margin-left: 2em; }
.attribute dt { float: left; font-style: italic;
  padding-right: 1ex; }
.attribute dd { margin-left: 0em; }

blockquote.std { color: #000000; background-color: #F1F1F1;
  border: 1px solid #D1D1D1;
  padding-left: 0.5em; padding-right: 0.5em; }
blockquote.stddel { text-decoration: line-through;
  color: #000000; background-color: #FFEBFF;
  border: 1px solid #ECD7EC;
  padding-left: 0.5em; padding-right: 0.5em; ; }

blockquote.stdins { text-decoration: underline;
  color: #000000; background-color: #C8FFC8;
  border: 1px solid #B3EBB3; padding: 0.5em; }

table { border: 1px solid black; border-spacing: 0px;
  margin-left: auto; margin-right: auto; }
th { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }
td { text-align: left; vertical-align: top;
  padding-left: 0.8em; border: none; }

</style>


<title>C++ Concurrent Queues</title>
</head>
<body>
<table style="margin-right: 0em">
<tbody>
<tr><th>Project:</th><td>ISO JTC1/SC22/WG21: Programming Language C++</td></tr>
<tr><th>Number:</th><td>D0260R7</td></tr>
<tr><th>Date:</th><td>2023-06-15</td></tr>
<tr><th>Audience</th><td>LEWG, SG1</td></tr>
<tr><th>Revises:</th><td>P0260R6</td></tr>
<tr><th>Author:</th><td>Lawrence Crowl, Chris Mysen, Detlef Vollmann, Gor Nishanov</td></tr>
<tr><th>Contact</th><td>dv@vollmann.ch</td></tr>
</tbody>
</table>


<h1>C++ Concurrent Queues</h1>

<p>
Lawrence Crowl, Chris Mysen, Detlef Vollmann, Gor Nishanov
</p>


<h2>Abstract</h2>

<p>
Concurrent queues are a fundamental structuring tool for concurrent programs.
We propose a concurrent queue concept and a concrete implementation (in P1958).
We propose a set of communication types
that enable loosely bound program components
to dynamically construct and safely share concurrent queues.
</p>


<h2>Contents</h2>

<p>
<a href="#Revision">Revision History</a><br>
<a href="#Introduction">Introduction</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#TargetVehicle">Target Vehicle</a><br/>
<a href="#PriorArt">Existing Practice</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PriorArtConcept">Concept of a Bounded Queue</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#PriorArtCpp">Bounded Queues with C++ Interface</a><br/>
<a href="#Conceptual">Conceptual Interface</a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#basic_operations">Basic Operations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#non_waiting">Non-Waiting Operations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#closed_queues">Closed Queues</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#empty_full">Empty and Full Queues</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#element_requirements">Element Type Requirements</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;<a href="#exception_handling">Exception Handling</a><br>
<a href="#Concrete">Concrete Queues</a><br>
<a href="#FeedbackPragueResponse">Response to Feedback by LEWGI at Prague 2020 meeting</a><br/>
<a href="#Implementation">Implementation</a><br>
<a href="#Historic">Historic Contents</a><br>
&nbsp;&nbsp;&nbsp;<a href="#Wording">Proposed Wording</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues">?.? Concurrent queues [conqueues]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.general">?.?.1 General [conqueues.general]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.syn">?.?.2 Header &lt;conqueue&gt; synopsis [conqueues.syn]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.status">?.?.3 Operation status [conqueues.status]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concepts">?.?.4 Concepts [conqueues.concepts]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.elemreq">?.?.4.1 Element requirements [conqueues.concept.elemreq]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.elemtype">?.?.4.2 Element type naming [conqueues.concept.elemtype]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.lockfree">?.?.4.3 Lock-free attribute operations [conqueues.concept.lockfree]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.lockfree">?.?.4.4 Synchronization [conqueues.concept.sync]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.state">?.?.4.4 State operations [conqueues.concept.state]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.wait">?.?.4.5 Waiting operations [conqueues.concept.wait]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.nonwait">?.?.4.6 Non-waiting operations [conqueues.concept.nonwait]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concept.type">?.?.4.7 Type concepts [conqueues.concept.type]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.concrete">?.?.5 Concrete queues [conqueues.concrete]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools">?.?.6 Tools [conqueues.tools]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.ends">?.?.6.1 Ends and Iterators [conqueues.tools.ends]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.back">?.?.6.1.1 Class template <code>generic_queue_back</code> [conqueues.tools.back]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.front">?.?.6.1.2 Class template <code>generic_queue_front</code> [conqueues.tools.front]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.binary">?.?.6.2 Binary interfaces [conqueues.tools.binary]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.base">?.?.6.2.1 Class template <code>queue_wrapper</code> [conqueues.tools.wrapper]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.binends">?.?.6.2.2 Binary ends [conqueues.tools.binends]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.managed">?.?.6.3 Managed Ends [conqueues.tools.managed]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.sharedback">?.?.6.3.1 Class template <code>shared_queue_back</code> [conqueues.tools.sharedback]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.front">?.?.6.3.2 Class template <code>shared_queue_front</code> [conqueues.tools.front]</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#conqueues.tools.shareends">?.?.6.3.3 Function template <code>share_queue_ends</code> [conqueues.tools.shareendsfront]</a><br>
&nbsp;&nbsp;&nbsp;<a href="#Abandoned">Abandoned Interfaces</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#non_block">Non-Blocking Operations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#push_front">Push Front Operations</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#queue_names">Queue Names</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#lock_free_buffer_queue">Lock-Free Buffer Queue</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#storage_iterators">Storage Iterators</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#queue_order">Queue Ordering</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#lock_free">Lock-Free Implementations</a><br>
&nbsp;&nbsp;&nbsp;<a href="#Concrete">Concrete Queues</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#buffer_queue">Locking Buffer Queue</a><br>
&nbsp;&nbsp;&nbsp;<a href="#Tools">Abandoned Additional Conceptual Tools</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#front_back">Fronts and Backs</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#streaming_iterators">Streaming Iterators</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Binary">Binary Interfaces</a><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#Managed">Managed Indirection</a><br>
</p>


<h2><a name="Revision">Revision History</a></h2>

<p>
  This paper revises P0260R6 - 2023-06-16 as follows.
  </p>
  
  <ul>
    <li>Fix typos.</li>
    <li>Implement LEWG feedback to derive conqueue_errc from system_error</li>
    <li>Implement LEWG feedback to add range constructor and go back to InputIterator</li>
    <li>size_t capacity() added</li>
  </ul>
  
<p>
This paper revises P0260R5 - 2023-01-15 as follows.
</p>

<ul>
  <li>Fixing typos.</li>
  <li>Added a scope for the target TS.</li>
  <li>Added questions to be answered by a TS.</li>
  <li>Added asynchronous interface</li>
</ul>

<p>
P0260R5 revises P0260R4 - 2020-01-12 as follows.
</p>

<ul>
  <li>Added more introductory material.</li>
  <li>Added response to feedback by LEWGI at Prague meeting 2020.</li>
  <li>Added section on existing practice.</li>
  <li>Replaced <code>value_pop</code> with <code>pop</code>.</li>
  <li>Replaced <code>is_lock_free</code> with <code>is_always_lockfree</code>.</li>
  <li>Removed <code>is_empty</code> and <code>is_full</code>.</li>
  <li>Added move-into parameter to <code>try_push(<var>Element</var>&amp;&amp;)</code></li>
  <li>Added note that exception thrown by the queue operations themselves are derived from <code>std::exception</code>.</li>
  <li>Added a note that the wording is partly invalid.</li>
  <li>Moved more contents into the "Abandoned" part to avoid confusion.</li>
</ul>

<p>
P0260R4 revised P0260R3 - 2019-01-20 as follows.
</p>

<ul>
<li><p>Remove the binding of <code>queue_op_status::success</code>
to a value of zero.</p></li>
<li><p>Correct stale use of the <code>Queue</code> template parameter
in <code>shared_queue_front</code> to <code>Value</code>.</p></li>
<li><p>Change the return type of <code>share_queue_ends</code>
from a <code>pair</code> to a custom struct.</p></li>
<li><p>Move the concrete queue proposal to a separate paper,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1958r0.html">P1958R0</a>.
</p></li>
</ul>

<p>
P0260R3 revised P0260R2 - 2017-10-15 as follows.
</p>

<ul>
<li><p>Convert <code>queue_wrapper</code>
to a <code>function</code>-like interface.
This conversion removes the <code>queue_base</code> class.
Thanks to Zach Lane for the approach.
</p></li>
<li><p>Removed the requirement that element types have a default constructor.
This removal implies that
statically sized buffers cannot use an array implmentation
and must grow a vector implementation to the maximum size.</p></li>
<li><p>Added a discussion of checking for output iterator end
in the wording.</p></li>
<li><p>Fill in synopsis section.</p></li>
<li><p>Remove stale discussion of <code>queue_owner</code>.</p></li>
<li><p>Move all abandoned interface discussion to a new section.</p></li>
<li><p>Update paper header to current practice.</p></li>
</ul>

<p>
P0260R2 revised P0260R1 - 2017-02-05 as follows.
</p>

<ul>
<li><p>Emphasize that non-blocking operations
were removed from the proposed changes.</p></li>
<li><p>Correct syntax typos for noexcept and template alias.</p></li>
<li><p>Remove <code>static</code> from <code>is_lock_free</code>
for <code>generic_queue_back</code> and <code>generic_queue_front</code>.
</p></li>
</ul>

<p>
P0260R1 revised P0260R0 - 2016-02-14 as follows.
</p>

<ul>
<li><p>Remove pure virtuals from <code>queue_wrapper</code>.</p></li>
<li><p>Correct <code>queue::pop</code> to <code>value_pop</code>.</p></li>
<li><p>Remove nonblocking operations.</p></li>
<li><p>Remove non-locking buffer queue concrete class.</p></li>
<li><p>Tighten up push/pop wording on closed queues.</p></li>
<li><p>Tighten up push/pop wording on synchronization.</p></li>
<li><p>Add note about possible non-FIFO behavior.</p></li>
<li><p>Define <code>buffer_queue</code> to be FIFO.</p></li>
<li><p>Make wording consistent across attributes.</p></li>
<li><p>Add a restriction on element special methods using the queue.</p></li>
<li><p>Make <code>is_lock_free()</code>
for only non-waiting functions.</p></li>
<li><p>Make <code>is_lock_free()</code>
static for non-indirect classes.</p></li>
<li><p>Make <code>is_lock_free() noexcept</code>.</p></li>
<li><p>Make <code>has_queue() noexcept</code>.</p></li>
<li><p>Make destructors <code>noexcept</code>.</p></li>
<li><p>Replace "throws nothing" with <code>noexcept</code>.</p></li>
<li><p>Make the remarks about the usefulness of <code>is_empty()</code>
and <code>is_full</code> into notes.</p></li>
<li><p>Make the non-static member functions
<code>is_</code>... and <code>has_</code>... functions
<code>const</code>.</p></li>
</ul>

<p>
P0260R0 revised N3533 - 2013-03-12 as follows.
</p>

<ul>
<li><p>Update links to source code.</p></li>
<li><p>Add wording.</p></li>
<li><p>Leave the name facility out of the wording.</p></li>
<li><p>Leave the push-front facility out of the wording.</p></li>
<li><p>Leave the reopen facility out of the wording.</p></li>
<li><p>Leave the storage iterator facility out of the wording.</p></li>
</ul>

<p>
N3532 revised N3434 = 12-0043 - 2012-01-14 as follows.
</p>

<ul>
<li><p>Add more exposition.</p></li>
<li><p>Provide separate non-blocking operations.</p></li>
<li><p>Add a section on the lock-free queues.</p></li>
<li><p>Argue against push-back operations.</p></li>
<li><p>Add a cautionary note
on the usefulness of <code>is_closed()</code>.</p></li>
<li><p>Expand the cautionary note
on the usefulness of <code>is_empty()</code>.
Add <code>is_full()</code>.</p></li>
<li><p>Add a subsection on element type requirements.</p></li>
<li><p>Add a subsection on exception handling.</p></li>
<li><p>Clarify ordering constraints on the interface.</p></li>
<li><p>Add a subsection on a lock-free concrete queue.</p></li>
<li><p>Add a section on content iterators,
distinct from the existing streaming iterators section.</p></li>
<li><p>Swap front and back names, as requested.</p></li>
<li><p>General expository cleanup.</p></li>
<li><p>Add an 'Revision History' section.</p></li>
</ul>

<p>
N3434 revised N3353 = 12-0043 - 2012-01-14 as follows.
</p>

<ul>
<li><p>Change the inheritance-based interface
to a pure conceptual interface.</p></li>
<li><p>Put 'try' operations into a separate subsection.</p></li>
<li><p>Add a subsection on non-blocking operations.</p></li>
<li><p>Add a subsection on push-back operations.</p></li>
<li><p>Add a subsection on queue ordering.</p></li>
<li><p>Merge the 'Binary Interface' and 'Managed Indirection' sections
into a new 'Conceptual Tools' section.
Expand on the topics and their rationale.</p></li>
<li><p>Add a subsection to 'Conceptual Tools'
that provides for type erasure.</p></li>
<li><p>Remove the 'Synopsis' section.</p></li>
<li><p>Add an 'Implementation' section.</p></li>
</ul>


<h2><a name="Introduction">Introduction</a></h2>

<p>
Queues provide a mechanism
for communicating data between components of a system.
</p>

<p>
The existing <code>deque</code> in the standard library
is an inherently sequential data structure.
Its reference-returning element access operations
cannot synchronize access to those elements
with other queue operations.
So, concurrent pushes and pops on queues
require a different interface to the queue structure.
</p>

<p>
Moreover,
concurrency adds a new dimension for performance and semantics.
Different queue implementation must trade off
uncontended operation cost, contended operation cost,
and element order guarantees.
Some of these trade-offs will necessarily result
in semantics weaker than a serial queue.
</p>

<p>
  Concurrent queues come in a several different flavours, e.g.
</p>
<ul>
  <li>bounded vs. unbounded</li>
  <li>blocking vs. overwriting</li>
  <li>single-ended vs. multi-ended</li>
  <li>strict FIFO ordering vs. priority based ordering</li>
</ul>
<p>
  The syntactic concept proposed here should be valid for all of these flavours,
  while the concrete semantics might differ.
</p>

<h3><a name="TargetVehicle">Target Vehicle</a></h3>
<p>
  This proposal targets a TS.
  It was originally sent to LEWG for inclusion into Concurrency TS v2.
  As Concurrency TS v2 will probably be published before this proposal
  is ready to be published, we propose to include concurrent queues into
  Concurrency TS v3 and publish this as soon as concurrent queues are ready.
  This leaves the door open for other proposal to share the same ship vehicle.
</p>

<p>
  The scope for Concurrency TS v3 would be the same as that for v2:
</p>

<p>
  "This document describes requirements for implementations of an interface
  that computer programs written in the C++ programming language may use
  to invoke algorithms with concurrent execution. The algorithms
  described by this document are realizable across a broad class
  of computer architectures."
</p>

<p>
  Should the committee decide to restrict the scope of the TS to only contain
  concurrent queues, we propose a slightly different scope:
</p>

<p>
  "This document describes requirements for implementations of an interface
  that computer programs written in the C++ programming language may use
  to communicate between different execution agents of algorithms with
  concurrent execution. The algorithms
  described by this document are realizable across a broad class
  of computer architectures."
</p>

<h4><a name="TSQuestions">Questions for a TS to Answer</a></h4>
<p>
  We expect that the TS will inform future work on a variety of questions,
  particularly those listed below, using real-world implementation
  experience that cannot be obtained without a TS.
</p>

<ul>
  <li>
    Is the proposed concept useful?
    Specifically, does it cover different implementations and does it
    work together with other concepts for concurrent queues, e.g.
    queues with only non-blocking functions or queues with an asynchronous
    interface?
  </li>
  <li>
    Is the concrete queue useful without an asynchronous interface?
    Can an asynchronous interface be added without extra overhead?
  </li>
  <li>
    What other concrete implementations should be provided?
  </li>
  <li>
    Is a queue that is ignorant of execution contexts from
    <code>std::execution</code> still useful?
  </li>
</ul>

<h2><a name="PriorArt">Existing Practice</a></h2>

<h3><a name="PriorArtConcept">Concept of a Bounded Queue</a></h3>

<p>
  The basic concept of a bounded queue with potentially blocking
  push and pop operations is very old and widely used.
  It's generally provided as an operating system level facility,
  like other concurrency primitives.
</p>

<p>
  POSIX 2001 has <code>mq</code> message queues (with priorities and timeout).
</p>

<p>
  Windows ?
</p>

<p>
  FreeRTOS, Mbed, vxWorks
</p>

<h3><a name="PriorArtCpp">Bounded Queues with C++ Interface</a></h3>

<p>
  Literature
</p>

<p>
  Boost
</p>

<p>
  TBB - 
  <b> TODO: Detlef, there was a comment in LEWG that TBB provides both. Here is the link to their docs:
    <a href="https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Concurrent_Queue_Classes.html">TBB Conqurrent Queue Classes</a>
    we need to do something here to address this comment.
  </b>
  </p>




<h2><a name="Conceptual">Conceptual Interface</a></h2>

<p>
We provide basic queue operations,
and then extend those operations to cover other important issues.
</p>

<p>
  By analogy with how <code>future</code> defines their errors, we introduce
<code>conque_errc</code> enum and <code>conqueue_error</code> as follows:
</p>

<pre>
  enum class conqueue_errc { success, empty, full, closed };

  template &lt;&gt;
  struct is_error_code_enum&lt;conqueue_errc&gt; : public true_type {};

  const error_category& conqueue_category() noexcept;

  error_code make_error_code(conqueue_errc e) noexcept;

  error_condition make_error_condition(conqueue_errc e) noexcept;

  class conqueue_error : public system_error;
</pre>

<pp>
These errors will be reported from concurrent queue operations as specified below.
</pp>

<h3><a name="basic_operations">Basic Operations</a></h3>

<p>
The essential solution to the problem of concurrent queuing
is to shift to value-based operations, 
rather than reference-based operations.
</p>

<p>
The basic operations are:
</p>

<dl>

<dt><code>void
<var>queue</var>::push(const T& x);</code></dt>
<dt><code>void
<var>queue</var>::push(T&& x);</code></dt>
<dt><code>bool
<var>queue</var>::push(const T& x, std::error_code& ec);</code></dt>
<dt><code>bool
<var>queue</var>::push(T&& x, std::error_code& ec);</code></dt>
<dd>
<p>
Pushes <code>x</code> onto the queue via copy or move construction.
The first version throws <code>std::conqueue_error(conqueue_errc::closed)</code> if the queue is closed.
The second version returns <code>true</code> on success, and </code> <code>false</code> and sets <code><var>ec</var></code>
to <code>error_code(conqueue_errc::closed)</code> if the queue is closed.
</p>
</dd>

<dt><code>T <var>queue</var>::pop();</code></dt>
<dt><code>std::optional&lt;T&gt;
    <var>queue</var>::pop(std::error_code& ec);</code></dt>
<dd>
<p>
Pops a value from the queue via move construction into the return value.
The first version throws <code>std::conqueue_error(conqueue_errc::closed)</code> if the queue is empty and 
closed; the second version, 
if the queue is empty and closed, returns <code>std::nullopt</code> and 
sets <code>ec</code> to <code>std::error_code(conqueue_errc::closed)</code>.
If queue is empty and open, the operation blocks until an element is available.
</p>

<!-- TODO: Detlef, confirm that this removal makes sense. It has already been seen by LEWG.
  Now it just clutters the APIs.
<p> <b>DISCUSSION: </b>
In the original buffer_queue paper, the pop function had signature 
<code>T pop_value()</code>. Subsequently, it was changed to 
<code>void pop(T&)</code> due to concern about the problem of loosing elements.
</p>
<p>
Unlike STL's combinations of <code>void pop()</code> and <code>T& front()</code> 
that are possible for synchronous cases, 
such a solution does not work for concurrent queues, 
where we cannot observe the value before popping it from the queue.
</p>
<p>
Comparing <code>T pop()</code> and <code>void pop(T&)</code> we believe that 
they are equivalent from exception safety standpoint and <code>T pop()</code> 
wins on ergonomics of usage.
<p>
Naming wise, we chose <code>T pop()</code> rather than 
<code>T pop_value()</code> for consistency with the rest of the APIs and due to 
<code>[[nodiscard]]</code> guarding against misuse 
(thus if a user imagined that pop API is <code>void pop()</code> by analogy with 
<code>std::stack</code>, for example, a compiler error will quickly bring them to their senses.
</p>
-->
</dd>

<p>
These operations will block when the queue is full or empty.
(Not all queue implementations can actually be full.)
These operations may block for mutual exclusion as well.
</p>

<p>
  <b>TODO: Detlef, the following paragraph needs to be updated to reflect to reflect LEWG non-answer :-). The paper
    number for std::expected exploration is P2921R0:
  </b>
    These version of APIs were reaffirmed by SG1 in Varna
  with one 
  <b>question for LEWG</b>. The pattern for 
  error reporting APIs should it be styled after <code>filesystem</code>
  which has error reporting versions are taking <var>ec</var>
  parameter, or we need to switch to <code>expected</code>
</p>

<h3><a name="async">Asynchronous Operations</a></h3>

<dl>
<dt><code>sender auto
<var>queue</var>::async_push(T x);</code></dt>
<dt><code>sender auto
<var>queue</var>::async_pop();</code></dt>
<dd>
<p>
These operations return a sender that will push or pop the element.
Senders must support cancellation and if the receiver 
is currently waiting on a push or pop operation and no longer
interested in performing the operation, it should be removed
from any waiting queues, if any, and be completed with <code>std::execution::set_stopped</code>.
</p>
</dd>
</dl>

<h3><a name="non_waiting">Non-Waiting Operations</a></h3>

<p>
Waiting on a full or empty queue can take a while,
which has an opportunity cost.
Avoiding that wait enables algorithms
to avoid queuing speculative work when a queue is full,
to do other work rather than wait for a push on a full queue, and
to do other work rather than wait for a pop on an empty queue.
</p>

<dl>

<dt><code>bool
<var>queue</var>::try_push(const T&amp; x, std::error_code& ec);</code></dt>
<dt><code>bool
  <var>queue</var>::try_push(T&& x, std::error_code& ec);</code></dt>
  
<dd>
<p>
If the queue is full or closed, returns <code>false</code> and sets the respective status in the <code>ec</code>.
Otherwise, push the value onto the queue via copy or move construction and returns <code>true</code>.
</p>
<!--
  TODO: Detlef. Confirm that removing the following makes sense.
  Since LEWG has seen this. We probably don't need this here.
<b>REVISITED in Varna</b>
  <p>
    The following version was introduced in response to LEWG-I concerns about
    loosing the element if an rvalue cannot be stored in the queue.
  </p>

    <code>queue_op_status
      <var>queue</var>::try_push(T&amp;&amp;, T&amp;);</code>
<p>
    However, SG1 reaffirmed the APIs above with the following rationale:
  </p>
  <p>
    It seems that it is possible in both versions:
  </p>
  <pre>
    T x = get_something();
    if (q.try_push(std::move(x))) ...
  </pre>
  <p>
  With two parameter version:
</p>
  <pre>
    T x;
    if (q.try_push(get_something(), x)) ...
  </pre>
  <p>
    Ergonomically they are roughly identical. API is slightly simpler with one argument version, therefore, we reverted to original one argument version.    
  </p>
  </quote>
</dd>
-->
<dt><code>optional&lt;T&gt;
<var>queue</var>::try_pop(std::error_code& ec);</code></dt>
<dd>
<p>
If the queue is empty, returns <code>nullopt</code> and set ec to <code>conqueue_errc::empty</code>.
Otherwise, pop the element from the queue via move construction into the optional.
Return <code>true</code> and set <var>ec</var> to <code>conqueue_errc::success</code>.
</p>
</dd>

</dl>

<p>
These operations will not wait when the queue is full or empty.
They may block for mutual exclusion.
</p>


<h3><a name="closed_queues">Closed Queues</a></h3>

<p>
Threads using a queue for communication
need some mechanism to signal when the queue is no longer needed.
The usual approach is add an additional out-of-band signal.
However, this approach suffers from the flaw that
threads waiting on either full or empty queues
need to be woken up when the queue is no longer needed.
To do that, you need access to the condition variables
used for full/empty blocking,
which considerably increases the complexity and fragility of the interface.
It also leads to performance implications with additional mutexes or atomics.
Rather than require an out-of-band signal,
we chose to directly support such a signal in the queue itself,
which considerably simplifies coding.
</p>

<p>
To achieve this signal, a thread may <dfn>close</dfn> a queue.
Once closed, no new elements may be pushed onto the queue.
Push operations on a closed queue
will either return <code>conqueue_errc::closed</code>
(when they have <var>ec</var> parameter)
or throw <code>conqueue_error(conqueue_errc::closed)</code>
(when they do not).
Elements already on the queue may be popped off.
When a queue is empty and closed,
pop operations will either
set <var>ec</var> to <code>conqueue_errc::closed</code> 
(when they have a <var>ec</var> parameter)
or throw <code>conqueue_error(conqueue_errc::closed)</code>
otherwise.
</p>

<p>
The additional operations are as follows.
They are essentially equivalent to the basic operations
except that they return a status,
avoiding an exception when queues are closed.
</p>

<dl>

<dt><code>void <var>queue</var>::close() noexcept;</code></dt>
<dd>
<p>
Close the queue.
</p>
</dd>

<dt><code>bool <var>queue</var>::is_closed() const noexcept;</code></dt>
<dd>
<p>
Return true iff the queue is closed.
</p>
</dd>

</dl>



<h3><a name="element_requirements">Element Type Requirements</a></h3>

<p>
The above operations require element types with
copy/move constructors, and destructor.
These operations may be trivial.
The copy/move constructors operators may throw,
but must leave the objects in a valid state
for subsequent operations.
</p>

<h3><a name="exception_handling">Exception Handling</a></h3>

<p>
    <code>push()</code> and <code>pop()</code> may throw an exceptions
    of type <code>conqueue_error</code> that's derived from
    <code>std::system_error</code> and will contain a
    <code>conqueue_errc</code>.
</p>

<p>
  Concurrent queues cannot completely hide the effect of exceptions
  thrown by the element type,
  in part because changes cannot be transparently undone
  when other threads are observing the queue.
</p>

<p>
Queues may rethrow exceptions
from storage allocation, mutexes, or condition variables.
</p>

<p>
If the <a href="#element_requirements">element type operations required</a>
do not throw exceptions,
then only the exceptions above are rethrown.
</p>

<p>
When an element copy/move may throw,
some queue operations have additional behavior.
</p>

<ul>

<li><p>
Construction shall rethrow,
destroying any elements allocated.
</p></li>

<li><p>
A push operation shall rethrow and the state of the queue is unaffected.
</p></li>

<li><p>
A pop operation shall rethrow and the element is popped from the queue.
The value popped is effectively lost.
(Doing otherwise would likely clog the queue with a bad element.)
</p></li>

</ul>


<h2><a name="Concrete">Concrete Queues</a></h2>

<p>
In addition to the concept,
the standard needs at least one concrete queue.
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1958r0.html">P1958R0</a>
provicdes one such concrete queue, <code>buffer_queue</code>.
</p>

<p>
  <code>buffer_queue</code> is outlined below:
</p>

<pre>
enum class conqueue_errc { success, empty, full, closed };

const error_category& conqueue_category() noexcept;
error_code make_error_code(conqueue_errc e) noexcept;
error_condition make_error_condition(conqueue_errc e) noexcept;

class conqueue_error : system_error { ... };

template &lt;typename T,
  class Allocator = std::allocator&lt;T&gt;&gt;
class buffer_queue
{
  buffer_queue() = delete;
  buffer_queue(const buffer_queue&amp;) = delete;
  buffer_queue&amp; operator =(const buffer_queue&amp;) = delete;
public:
  typedef T value_type;

  // construct/destroy
  explicit buffer_queue(size_t max_elems, const Allocator&amp; alloc = Allocator());
  explicit buffer_queue(std::initializer_list&lt;T&gt;, size_t max_elems = 0, 
                        const Allocator&amp; alloc = Allocator());
  template &lt;typename InputIterator&gt;
    buffer_queue(InputIterator begin, InputIterator end, size_t max_elems = 0,
                 const Allocator&amp; alloc = Allocator());
  template &lt;<it>container-compatible-range</it>&lt;T&gt; R&gt;
    buffer_queue(from_range_t, R&& rg, size_t max_elems = 0, 
                 const Allocator&amp; alloc = Allocator());

  ~buffer_queue() noexcept;

  // observers
  size_t capacity() const noexcept;
  bool is_closed() const noexcept;
  static constexpr bool is_always_lock_free() noexcept;

  // modifiers
  void close() noexcept;

  T pop();
  optional&lt;T&gt; pop(std::error_code& ec);
  optional&lt;T&gt; try_pop(std::error_code& ec);

  void push(const T& x);
  void push(T&& x);
  bool push(const T& x, std::error_code& ec);
  bool push(T&& x, std::error_code& ec);
  bool try_push(const T& x, std::error_code& ec);
  bool try_push(T&& x, std::error_code& ec);
};
</pre>

<pp>
  buffer_queue is only allowed to allocate in its constructor.
</pp>

<pp>
constructors that take initializing sequence are allowed to omit
size_t max_elem argument that will be then assumed to be equal to 
the size of the initialization sequence.
</pp>

<h2><a name="FeedbackPragueResponse">Response to Feedback by LEWGI at Prague 2020 meeting</a></h2>

<p>
  At the Prague meeting in February 2020 LEWGI provided feedback
  an set some action items.
</p>

<dl>
  <dt>
    "Explore P0059 <code>ring_buffer</code> prior art and document it in paper."
  </dt>
  <dd>
    <code>ring_buffer</code> is like <code>std::queue</code> is a sequential
    data structure and therefore provides a completely different
    interface than concurrent queues.
  </dd>
</dl>

<dl>
  <dt>
    "Consider removing <code>value_pop</code> to increase consensus."
  </dt>
  <dd>
    <code>value_pop</code> was replaced by <code>pop</code>
    that doesn't have the problem of loosing elements.
  </dd>
</dl>

<dl>
  <dt>
    "Consider removing <code>is_empty</code> and  <code>is_full</code>
    to increase consensus."
  </dt>
  <dd>
    Done.
  </dd>
</dl>

<dl>
  <dt>
    "Consider removing <code>is_lock_free</code> to increase consensus.
    If <code>is_lock_free</code> remains, add <code>is_always_lock_free</code>
    (a la <code>atomic</code>)."
  </dt>
  <dd>
    <code>is_lock_free</code> was dropped but <code>is_always_lock_free</code>
    was added anyways.
  </dd>
</dl>

<dl>
  <dt>
    "Remove the maybe-consuming <code>try_push(&amp;&amp;)</code>.
    Investigate prior art (such as TBB's <code>concurrent_queue</code>)
    and add either:
  </dt>
    <ul>
      <li>
        An always-consuming <code>try_push(&amp;&amp;)</code>
        which returns <code>queue_op_status</code>,
      </li>
      <li>
        An always-consuming <code>try_push(&amp;&amp;)</code> which
        returns the input on failure."
      </li>
    </ul>
  <dd>
    TBB's <code>concurrent_queue</code> doesn't have <code>try_push</code>.
    <code>try_push(&amp;&amp;)</code> now has an additional parameter
    that gets the element if it couldn't be pushed.
  </dd>
</dl>

<dl>
  <dt>
    "Require <code>buffer_queue</code> to allocate all storage only once".<br/>
    "Require <code>buffer_queue</code> to allocate all storage
    during construction".<br/>
    "Instead of throwing <code>queue_op_status</code> objects,
          add a standard library exception type and throw that."
  </dt>
  <dd>
    These requests are all valid and added (partly to P1958R1).
  </dd>
</dl>


<h2><a name="Implementation">Implementation</a></h2>

<p>
  An implementation is available at
  <a href="https://github.com/GorNishanov/conqueue">
    https://github.com/GorNishanov/conqueue</a>.
</p>
<p>
A free, open-source implementation of an earlier version of these interfaces
is avaliable at the Google Concurrency Library project
at 
<a href="https://github.com/alasdairmackintosh/google-concurrency-library">
https://github.com/alasdairmackintosh/google-concurrency-library</a>.
The concrete <code>buffer_queue</code> is in
<a href="https://github.com/alasdairmackintosh/google-concurrency-library/blob/master/include/buffer_queue.h">
..../blob/master/include/buffer_queue.h</a>.
The concrete <code>lock_free_buffer_queue</code> is in
<a href="https://github.com/alasdairmackintosh/google-concurrency-library/blob/master/include/lock_free_buffer_queue.h">
..../blob/master/include/lock_free_buffer_queue.h</a>.
The corresponding implementation of the conceptual tools is in
<a href="https://github.com/alasdairmackintosh/google-concurrency-library/blob/master/include/queue_base.h">
..../blob/master/include/queue_base.h</a>.
</p>


<h1><a name="Historic">Historic Contents</a></h1>

<strong>The Contents below is for historic reference only.</strong>

<h2><a name="Wording">Proposed Wording</a></h2>

<p>
  <strong>
    Note: This wording is left for general reference.
    It was not updated from previous proposals as first the design
    should be fixed.
    So the wording here partly contradicts the design proposed above.
    In these cases the design is proposed and not the wording!
  </strong>
</p>

<p>
The concurrent queue container definition is as follows.
The section, paragraph, and table references
are based on those of
<cite><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4567.pdf"> N4567</a>
Working Draft, Standard for Programming Language C++</cite>,
Richard Smith, November 2015.
</p>


<h3><a name="conqueues">?.? Concurrent queues [conqueues]</a></h3>

<p>
Add a new section.
</p>


<h3><a name="conqueues.general">?.?.1 General [conqueues.general]</a></h3>

<p>
Add a new section.
</p>

<blockquote class="stdins">
<p>
This section provides mechanisms for concurrent access to a queue.
These mechanisms ease the production of race-free programs
(1.10 [intro.multithread]).
</p>
</blockquote>


<h3><a name="conqueues.syn">?.?.2 Header &lt;conqueue&gt; synopsis [conqueues.syn]</a></h3>

<p>
Add a new section.
</p>

<blockquote class="stdins">
<pre><code>
enum class queue_op_status { success, empty, full, closed };

template &lt;typename Value&gt; class buffer_queue;

template &lt;typename Queue&gt; class generic_queue_back;
template &lt;typename Queue&gt; class generic_queue_front;
template &lt;typename Value&gt; class queue_base;
template &lt;typename Value&gt;
  using queue_back = generic_queue_back&lt; queue_base&lt; Value &gt; &gt;;
template &lt;typename Value&gt;
  using queue_front = generic_queue_front&lt; queue_base&lt; Value &gt; &gt;;
template &lt;typename Queue&gt; class queue_wrapper;

template &lt;typename Value&gt; class shared_queue_back;
template &lt;typename Value&gt; class shared_queue_front;
template &lt;typename Value&gt; class shared_queue_ends;
template &lt;typename Queue, typename ... Args&gt;
  shared_queue_ends&lt;typename Queue::value_type&gt;;
  share_queue_ends(Args ... args); 
</code></pre>
</blockquote>


<h3><a name="conqueues.status">?.?.3 Operation status [conqueues.status]</a></h3>

<p>
Add a new section.
</p>

<blockquote class="stdins">
<p>
Many concurrent queue operations return a status
in the form of the following enumeration.
</p>

<p class="function">
<code>enum class queue_op_status</code>
</p>

<dl class="attribute">
<dt>Enumerators:</dt>
<dd><p>
<code>success = 0, empty, full, closed</code>
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.concepts">?.?.4 Concepts [conqueues.concepts]</a></h3>

<p>
Add a new section.
</p>

<blockquote class="stdins">
<p>
This section provides the conceptual operations for concurrent queues
of type <code><var>queue</var></code> of <code><var>Element</var></code> types.
</p>
</blockquote>


<h3><a name="conqueues.concept.elemreq">?.?.4.1 Element requirements [conqueues.concept.elemreq]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">
<p>
The types of the elements of a concurrent queue must provide
either or both of a copy constructor or a move constructor,
either or both of a copy assignment operator or a move assignment operator,
and a destructor.
</p>

<p>
Any copy/more constructor or copy/move assignment operator that throws
shall leave the objects in a valid state for subsequent operations.
</p>

<p>
None of the above constructors, assignments or destructor
may call any operation on a concurrent queue
for which their objects may become a member.
[<i>Note:</i>
Queues may hold an internal lock while performing the above operations,
and if they were to call a queue operation, deadlock would result.
&mdash;<i>end note</i>]
</p>

</blockquote>


<h3><a name="conqueues.concept.elemtype">?.?.4.2 Element type naming [conqueues.concept.elemtype]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">
<p>
The queue class shall provide a typedef to its element value type.
</p>

<p class="function">
<code>typedef <var>implementation-defined</var> value_type;</code>
</p>

</blockquote>


<h3><a name="conqueues.concept.lockfree">?.?.4.3 Lock-free attribute operations [conqueues.concept.lockfree]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
A queue type provides lock-free operations (1.10 [intro.multithread],
or it does not.
</p>

<p class="function">
<code>static bool <var>queue</var>::is_lock_free() noexcept;</code>
</p>

<dl class="attribute">
<dt>Returns:</dt>
<dd><p>
If the non-waiting operations of the queue type are lock-free,
<code>true</code>.
Otherwise, <code>false</code>.
</p></dd>

<dt>Remark:</dt>
<dd><p>
The function returns the same result for all instances of the type.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.concept.sync">?.?.4.4 Synchronization [conqueues.concept.sync]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
For synchronization purposes, and unless otherwise stated,
all queue operations appear to operate on a single memory location,
all non-const queue operations
appear to be sequentially consistent atomic read-modify-write operations,
and all const queue operations appear to be atomic loads from this location.
[<i>Note:</i>
In particular,
all queue operations appear to execute in a single global order,
that is part of the total order <var>S</var> (29.3 [atomics.order])
of sequentially consistent operations.
Each non-const queue operation <var>A</var>
strongly happens before every operation on the same queue
that follows <var>A</var> in <var>S</var>.
Whether or not the queue preserves a FIFO order
is a property of the concrete class.
&mdash;<i>end note</i>]
</p>

<p class="function">
<code>static bool <var>queue</var>::is_lock_free() noexcept;</code>
</p>

<dl class="attribute">
<dt>Returns:</dt>
<dd><p>
If the non-waiting operations of the queue type are lock-free,
<code>true</code>.
Otherwise, <code>false</code>.
</p></dd>

<dt>Remark:</dt>
<dd><p>
The function returns the same result for all instances of the type.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.concept.state">?.?.4.4 State operations [conqueues.concept.state]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
Upon construction, every queue shall be in an open state.
It may move to a closed state,
but shall not move back to an open state.
</p>

<p class="function">
<code>void <var>queue</var>::close() noexcept;</code>
</p>

<dl class="attribute">

<dt>Effects:</dt>
<dd><p>
Closes the queue.
No pushes subsequent to the close shall succeed.
</p></dd>

</dl>

<p class="function">
<code>bool <var>queue</var>::is_closed() const noexcept;</code>
</p>

<dl class="attribute">

<dt>Returns:</dt>
<dd><p>
<code>true</code> if the queue is closed,
otherwise, <code>false</code>
</p></dd>

</dl>

</blockquote>


<h3><a name="conqueues.concept.wait">?.?.4.5 Waiting operations [conqueues.concept.wait]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p class="function">
<code>void <var>queue</var>::push(const <var>Element</var>&amp;);</code>
<br>
<code>void <var>queue</var>::push(<var>Element</var>&amp;&amp;);</code>
</p>

<dl class="attribute">

<dt>Effects:</dt>
<dd><p>
If the queue is closed, throws an exception.
Otherwise, if space is available on the queue,
copies or moves the <code><var>element</var></code> onto the queue and returns.
Otherwise, waits until space is available or the queue is closed.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the queue is unaffected
and the push shall rethrow the exception.
If the operation cannot otherwise complete because the queue is closed,
throws <code>queue_op_status::closed</code>.
</p></dd>

</dl>

<p class="function">
<code>void <var>queue</var>::pop(<var>Element</var>&amp;);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
If an element is available on the queue,
moves the element from the queue to the parameter and returns.
Otherwise, if the queue is closed, throws an exception.
Otherwise, waits until an element is available or the queue is closed.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the element is popped
and the pop shall rethrow the exception.
If the operation cannot otherwise complete because the queue is closed,
throws <code>queue_op_status::closed</code>.
</p></dd>

</dl>

<p class="function">
<code>queue_op_status <var>queue</var>::wait_push(const <var>Element</var>&amp;);</code>
<br>
<code>queue_op_status <var>queue</var>::wait_push(<var>Element</var>&amp;&amp;);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
If the queue is closed, returns.
Otherwise, if space is available on the queue,
copies or moves the <code><var>element</var></code> onto the queue and returns.
Otherwise, waits until space is available or the queue is closed.
</p></dd>

<dt>Returns:</dt>
<dd><p>
If the queue was closed, <code>queue_op_status::closed</code>.
Otherwise, the push was successful, <code>queue_op_status::success</code>.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the queue is unaffected
and the push shall rethrow the exception.
</p></dd>

</dl>

<p class="function">
<code>queue_op_status <var>queue</var>::wait_pop(<var>Element</var>&amp;);</code>
</p>

<dl class="attribute">

<dt>Effects:</dt>
<dd><p>
If an element is available on the queue,
moves the element from the queue to the parameter
and returns.
Otherwise, if the queue is closed, returns.
Otherwise, waits until an element is available or the queue is closed.
</p></dd>

<dt>Returns:</dt>
<dd><p>
If the queue was closed, <code>queue_op_status::closed</code>.
Otherwise, the pop was successful, <code>queue_op_status::success</code>.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the element is popped
and the pop shall rethrow the exception.
</p></dd>

</dl>

</blockquote>


<h3><a name="conqueues.concept.nonwait">?.?.4.6 Non-waiting operations [conqueues.concept.nonwait]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p class="function">
<code>queue_op_status <var>queue</var>::try_push(const <var>Element</var>&amp;);</code>
<br>
<code>queue_op_status <var>queue</var>::try_push(<var>Element</var>&amp;&amp;);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
If the queue is closed, returns.
Otherwise, if space is available on the queue,
copies or moves the <code><var>element</var></code> onto the queue and returns.
Otherwise, returns.
</p></dd>

<dt>Returns:</dt>
<dd><p>
If the queue was closed, <code>queue_op_status::closed</code>.
Otherwise, if the push was successful, <code>queue_op_status::success</code>.
Otherwise, space was unavailable, <code>queue_op_status::full</code>.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the queue is unaffected
and the push shall rethrow the exception.
</p></dd>

</dl>

<p class="function">
<code>queue_op_status <var>queue</var>::try_pop(<var>Element</var>&amp;);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
If an element is available on the queue,
moves the element from the queue to the parameter and returns.
Otherwise, returns.
</p></dd>

<dt>Returns:</dt>
<dd><p>
If the pop was successful, <code>queue_op_status::success</code>.
Otherwise, if the queue is closed, <code>queue_op_status::closed</code>.
Otherwise, no element was available, <code>queue_op_status::empty</code>.
</p></dd>

<dt>Throws:</dt>
<dd><p>
Any exception from operations on
storage allocation, mutexes, or condition variables.
If an element copy/move operation throws,
the state of the element is popped
and the pop shall rethrow the exception.
</p></dd>

</dl>

</blockquote>


<h3><a name="conqueues.concept.type">?.?.4.7 Type concepts [conqueues.concept.type]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
The <code>WaitingConcurrentQueue</code> concept
provides all of the operations specified above.
</p>

<p>
The <code>NonWaitingConcurrentQueue</code> concept
provides all of the operations specified above,
except the waiting operations ([conqueues.concept.wait]).
A <code>NonWaitingConcurrentQueue</code> is lock-free
(1.10 [intro.multithread])
when its member function <code>is_lock_free</code> reports true.
</p>

<p>
The <code>WaitingConcurrentQueueBack</code> concept
provides all of the operations specified above
except the pop operations.
</p>

<p>
The <code>WaitingConcurrentQueueFront</code> concept
provides all of the operations specified above
except the push operations.
</p>

<p>
The <code>NonWaitingConcurrentQueueBack</code> concept
provides all of the operations specified above
except the pop operations and the waiting push operations.
A <code>NonWaitingConcurrentQueueBack</code> is lock-free
(1.10 [intro.multithread])
when its member function <code>is_lock_free</code> reports true.
</p>

<p>
The <code>NonWaitingConcurrentQueueFront</code> concept
provides all of the operations specified above
except the push operations and the waiting pop operations.
A <code>NonWaitingConcurrentQueueFront</code> is lock-free
(1.10 [intro.multithread])
when its member function <code>is_lock_free</code> reports true.
</p>

</blockquote>


<h3><a name="conqueues.concrete">?.?.5 Concrete queues [conqueues.concrete]</a></h3>

<p>
Add a new section, with content to be provided by other papers.
</p>


<h3><a name="conqueues.tools">?.?.6 Tools [conqueues.tools]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">
<p>
Additional tools help to use and manage concurrent queues.
</p>
</blockquote>


<h3><a name="conqueues.tools.ends">?.?.6.1 Ends and Iterators [conqueues.tools.ends]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">
<p>
Access to only a single end of a queue is a valuable code structuring tool.
A single end can also provide
unambiguous <code>begin</code> and <code>end</code> operations
that return iterators.
</p>

<p>
Because queues may be closed
and hence accept no further pushes,
output iterators must also be checked for having reached the end,
ie. having been closed.
[<i>Example:</i>
</p>
<pre class="example"><code>void iterate(
    generic_queue_back&lt;buffer_queue&lt;int&gt;&gt;::iterator bitr,
    generic_queue_back&lt;buffer_queue&lt;int&gt;&gt;::iterator bend,
    generic_queue_front&lt;buffer_queue&lt;int&gt;&gt;::iterator fitr,
    generic_queue_front&lt;buffer_queue&lt;int&gt;&gt;::iterator fend,
    int (*compute)( int ) )
{
    while ( fitr != fend &amp;&amp; bitr != bend )
        *bitr++ = compute(*fitr++);
}</code>
</pre>
<p>
&mdash;<i>end example</i>]
</p>
</blockquote>


<h3><a name="conqueues.tools.back">?.?.6.1.1 Class template <code>generic_queue_back</code> [conqueues.tools.back]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>template &lt;typename Queue&gt;
class generic_queue_back
{
public:
  typedef typename Queue::value_type value_type;
  typedef value_type&amp; reference;
  typedef const value_type&amp; const_reference;

  typedef <var>implementation-defined</var> iterator;
  typedef const iterator const_iterator;

  generic_queue_back(Queue&amp; queue);
  generic_queue_back(Queue* queue);
  generic_queue_back(const generic_queue_back&amp; other) = default;
  generic_queue_back&amp; operator =(const generic_queue_back&amp; other) = default;

  void close() noexcept;
  bool is_closed() const noexcept;
  bool is_empty() const noexcept;
  bool is_full() const noexcept;
  bool is_lock_free() const noexcept;
  bool has_queue() const noexcept;

  iterator begin();
  iterator end();
  const iterator cbegin();
  const iterator cend();

  void push(const value_type&amp; x);
  queue_op_status wait_push(const value_type&amp; x);
  queue_op_status try_push(const value_type&amp; x);

  void push(value_type&amp;&amp; x);
  queue_op_status wait_push(value_type&amp;&amp; x);
  queue_op_status try_push(value_type&amp;&amp; x);
};
</pre>

<p>
The class template <code>generic_queue_back</code>
implements <code>WaitingConcurrentQueueBack</code>
</p>

<p class="function">
<code>generic_queue_back(Queue&amp; queue);</code>
<br>
<code>generic_queue_back(Queue* queue);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Constructs the queue back with a pointer to the queue object given.
</p></dd>
</dl>

<p class="function">
<code>~generic_queue_back() noexcept;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Destroys the queue back.
</p></dd>
</dl>

<p class="function">
<code>bool has_queue() const noexcept;</code>
</p>

<dl class="attribute">
<dt>Returns:</dt>
<dd><p>
<code>true</code> if the contained pointer is not null.
<code>false</code> otherwise.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.tools.front">?.?.6.1.2 Class template <code>generic_queue_front</code> [conqueues.tools.front]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>template &lt;typename Queue&gt;
class generic_queue_front
{
public:
  typedef typename Queue::value_type value_type;
  typedef value_type&amp; reference;
  typedef const value_type&amp; const_reference;

  typedef <var>implementation-defined</var> iterator;
  typedef const iterator const_iterator;

  generic_queue_front(Queue&amp; queue);
  generic_queue_front(Queue* queue);
  generic_queue_front(const generic_queue_front&amp; other) = default;
  generic_queue_front&amp; operator =(const generic_queue_front&amp; other) = default;

  void close() noexcept;
  bool is_closed() const noexcept;
  bool is_empty() const noexcept;
  bool is_full() const noexcept;
  bool is_lock_free() const noexcept;
  bool has_queue() const noexcept;

  iterator begin();
  iterator end();
  const iterator cbegin();
  const iterator cend();

  value_type value_pop();
  queue_op_status wait_pop(value_type&amp; x);
  queue_op_status try_pop(value_type&amp; x);
};
</pre>

<p>
The class template <code>generic_queue_front</code>
implements <code>WaitingConcurrentQueueFront</code>
</p>

<p class="function">
<code>generic_queue_front(Queue&amp; queue);</code>
<br>
<code>generic_queue_front(Queue* queue);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Constructs the queue front with a pointer to the queue object given.
</p></dd>
</dl>

<p class="function">
<code>~generic_queue_front() noexcept;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Destroys the queue front.
</p></dd>
</dl>

<p class="function">
<code>bool has_queue() const noexcept;</code>
</p>

<dl class="attribute">
<dt>Returns:</dt>
<dd><p>
<code>true</code> if the contained pointer is not null.
<code>false</code> otherwise.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.tools.binary">?.?.6.2 Binary interfaces [conqueues.tools.binary]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
Occasionally it is best to have a binary interface
to any concurrent queue of a given element type.
This binary interface is provided by a wrapper class
that erases the type of the concrete queue class.
</p>

</blockquote>


<h3><a name="conqueues.tools.base">?.?.6.2.1 Class template <code>queue_wrapper</code> [conqueues.tools.wrapper]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>
<code>template&lt;typename Value&gt;
struct queue_wrapper
{
  using value_type = Value;

  template&lt;typename Queue&gt;
  queue_wrapper(Queue * arg);
  template&lt;typename Queue&gt;
  queue_wrapper(Queue &amp; arg);
  ~queue_wrapper() noexcept;

  void close() noexcept;
  bool is_closed() const noexcept;
  bool is_empty() const noexcept;
  bool is_full() const noexcept;
  bool is_lock_free() const noexcept;

  void push(const value_type &amp; x);
  queue_op_status wait_push(const value_type &amp; x);
  queue_op_status try_push(const value_type &amp; x);
  queue_op_status nonblocking_push(const value_type &amp; x);

  void push(value_type &amp;&amp; x);
  queue_op_status wait_push(value_type &amp;&amp; x);
  queue_op_status try_push(value_type &amp;&amp; x);
  queue_op_status nonblocking_push(value_type &amp;&amp; x);

  value_type value_pop();
  queue_op_status wait_pop(value_type &amp;);
  queue_op_status try_pop(value_type &amp;);
  queue_op_status nonblocking_pop(value_type &amp;);
};</code>
</pre>

<p>
The template type parameter <code>Queue</code>
and the he class template <code>queue_base</code>
shall implement the <code>WaitingConcurrentQueue</code> concept.
</p>

<p class="function">
<code>  template&lt;typename Queue&gt; queue_wrapper(Queue* arg);
  template&lt;typename Queue&gt; queue_wrapper(Queue&amp; arg);</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Constructs the queue wrapper,
referencing the given queue.
</p></dd>

</dl>

<p class="function">
<code>~queue_base() noexcept;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Destroys the queue wrapper, but not the referenced queue.
</p></dd>

</dl>

</blockquote>


<h3><a name="conqueues.tools.binends">?.?.6.2.2 Binary ends [conqueues.tools.binends]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p>
In addition to binary interfaces to queues,
binary interfaces to ends are also useful.
</p>

<pre><code>template &lt;typename Value&gt;
using queue_back = generic_queue_back&lt; queue_wrapper&lt; Value &gt; &gt;;
template &lt;typename Value&gt;
using queue_front = generic_queue_front&lt; queue_wrapper&lt; Value &gt; &gt;;</code>
</pre>

</blockquote>


<h3><a name="conqueues.tools.managed">?.?.6.3 Managed Ends [conqueues.tools.managed]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">
<p>
Automatically managing references to queues
can be helpful when queues are used as a communication medium.
</p>
</blockquote>


<h3><a name="conqueues.tools.sharedback">?.?.6.3.1 Class template <code>shared_queue_back</code> [conqueues.tools.sharedback]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>template &lt;typename Value&gt;
class shared_queue_back
{
public:
  typedef typename Value value_type;
  typedef value_type&amp; reference;
  typedef const value_type&amp; const_reference;

  typedef <var>implementation-defined</var> iterator;
  typedef const iterator const_iterator;

  shared_queue_back(const shared_queue_back&amp; other);
  shared_queue_back&amp; operator =(const shared_queue_back&amp; other);

  void close() noexcept;
  bool is_closed() const noexcept;
  bool is_empty() const noexcept;
  bool is_full() const noexcept;
  bool is_lock_free() const noexcept;

  iterator begin();
  iterator end();
  const iterator cbegin();
  const iterator cend();

  void push(const value_type&amp; x);
  queue_op_status wait_push(const value_type&amp; x);
  queue_op_status try_push(const value_type&amp; x);

  void push(value_type&amp;&amp; x);
  queue_op_status wait_push(value_type&amp;&amp; x);
  queue_op_status try_push(value_type&amp;&amp; x);
};
</pre>

<p>
The class template <code>shared_queue_back</code>
implements <code>WaitingConcurrentQueueBack</code>
</p>

<p class="function">
<code>shared_queue_back(const shared_queue_back&amp; other);</code>
<br>
<code>shared_queue_back&amp; operator =(const shared_queue_back&amp; other) = default;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Copy the pointer to the queue,
but keep the back of the queue reference counted.
</p></dd>
</dl>

<p class="function">
<code>~shared_queue_back() noexcept;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Destroys the queue back.
If this is the last back reference,
and there are no front references,
destroy the queue.
If this is the last back reference,
and there are front references,
close the queue.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.tools.sharedfront">?.?.6.3.2 Class template <code>shared_queue_front</code> [conqueues.tools.sharedfront]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>template &lt;typename Value&gt;
class shared_queue_front
{
public:
  typedef typename Value value_type;
  typedef value_type&amp; reference;
  typedef const value_type&amp; const_reference;

  typedef <var>implementation-defined</var> iterator;
  typedef const iterator const_iterator;

  shared_queue_front(Queue&amp; queue);
  shared_queue_front(Queue* queue);
  shared_queue_front(const shared_queue_front&amp; other) = default;
  shared_queue_front&amp; operator =(const shared_queue_front&amp; other) = default;

  void close() noexcept;
  bool is_closed() const noexcept;
  bool is_empty() const noexcept;
  bool is_full() const noexcept;
  bool is_lock_free() const noexcept;
  bool has_queue() const noexcept;

  iterator begin();
  iterator end();
  const iterator cbegin();
  const iterator cend();

  value_type value_pop();
  queue_op_status wait_pop(value_type&amp; x);
  queue_op_status try_pop(value_type&amp; x);
};
</pre>

<p>
The class template <code>shared_queue_front</code>
implements <code>WaitingConcurrentQueueFront</code>
</p>

<p class="function">
<code>shared_queue_front(const shared_queue_front&amp; other);</code>
<br>
<code>shared_queue_front&amp; operator =(const shared_queue_front&amp; other) = default;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Copy the pointer to the queue,
but keep the front of the queue reference counted.
</p></dd>
</dl>

<p class="function">
<code>~shared_queue_front() noexcept;</code>
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Destroys the queue front.
If this is the last front reference,
and there are no back references,
destroy the queue.
If this is the last front reference,
and there are back references,
close the queue.
</p></dd>
</dl>

</blockquote>


<h3><a name="conqueues.tools.shareqends">?.?.6.3.3 Class template <code>shared_queue_ends</code> [conqueues.tools.shareqends]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<pre>template &lt;typename Value&gt;
class shared_queue_ends
{
public:
  shared_queue_back&lt;Value&gt; back;
  shared_queue_front&lt;Value&gt; front;
};
</pre>

</blockquote>


<h3><a name="conqueues.tools.shareends">?.?.6.3.4 Function template <code>share_queue_ends</code> [conqueues.tools.shareends]</a></h3>

<p>
Add a new section:
</p>

<blockquote class="stdins">

<p class="function">
template &lt;typename Queue, typename ... Args&gt;
<br>
shared_queue_ends&lt;typename Queue::value_type&gt;
<br>
share_queue_ends(Args ... args);
</p>

<dl class="attribute">
<dt>Effects:</dt>
<dd><p>
Constructs a <code>Queue</code> with the given <code>Args</code>.
Initializes a set of reference counters for that queue.
</p></dd>

<dt>Returns:</dt>
<dd><p>
a <code>shared_queue_ends</code>
consisting of one <code>shared_queue_back</code>
and one <code>shared_queue_front</code>
for the constructed queue.
</p></dd>
</dl>

</blockquote>



<h2><a name="Abandoned">Abandoned Interfaces</a></h2>

<h3><a name="reopen">Re-opening a Queue</a></h3>


<p>
There are use cases for opening a queue that is closed.
While we are not aware of an implementation
in which the ability to reopen a queue would be a hardship,
we also imagine that such an implementation could exist.
Open should generally only be called if the queue is closed and empty,
providing a clean synchronization point,
though it is possible to call open on a non-empty queue.
An open operation following a close operation
is guaranteed to be visible after the close operation
and the queue is guaranteed to be open upon completion of the open call.
(But of course, another close call could occur immediately thereafter.)
</p>

<dl>

<dt><code>void <var>queue</var>::open();</code></dt>
<dd>
<p>
Open the queue.
</p>
</dd>

</dl>

<p>
Note that when <code>is_closed()</code> returns false,
there is no assurance that
any subsequent operation finds the queue closed
because some other thread may close it concurrently.
</p>

<p>
If an open operation is not available,
there is an assurance that once closed, a queue stays closed.
So, unless the programmer takes care
to ensure that all other threads will not close the queue,
only a return value of true has any meaning.
</p>

<p>
Given these concerns with reopening queues,
we do not propose wording to reopen a queue.
</p>



<h3><a name="non_block">Non-Blocking Operations</a></h3>

<p>
For cases when blocking for mutual exclusion is undesirable,
one can consider non-blocking operations.
The interface is the same as the try operations
but is allowed to also return <code>queue_op_status::busy</code>
in case the operation is unable to complete without blocking.
</p>

<dl>
<dt><code>queue_op_status
<var>queue</var>::nonblocking_push(const <var>Element</var>&amp;);</code></dt>
<dt><code>queue_op_status
<var>queue</var>::nonblocking_push(<var>Element</var>&amp;&amp;);</code></dt>
<dd>
<p>
If the operation would block, return <code>queue_op_status::busy</code>. 
Otherwise, if the queue is full, return <code>queue_op_status::full</code>.
Otherwise, push the <code><var>Element</var></code> onto the queue.
Return <code>queue_op_status::success</code>.
</p>
</dd>

<dt><code>queue_op_status
<var>queue</var>::nonblocking_pop(<var>Element</var>&amp;);</code></dt>
<dd>
<p>
If the operation would block, return <code>queue_op_status::busy</code>. 
Otherwise, if the queue is empty, return <code>queue_op_status::empty</code>.
Otherwise, pop the <code><var>Element</var></code> from the queue.
The element will be moved out of the queue in preference to being copied.
Return <code>queue_op_status::success</code>.
</p>
</dd>
</dl>

<p>
These operations will neither wait nor block.
However, they may do nothing.
</p>

<p>
The non-blocking operations highlight a terminology problem.
In terms of synchronization effects,
<code>nonwaiting_push</code> on queues
is equivalent to <code>try_lock</code> on mutexes.
And so one could conclude that
the existing <code>try_push</code>
should be renamed <code>nonwaiting_push</code>
and <code>nonblocking_push</code>
should be renamed <code>try_push</code>.
However, at least Thread Building Blocks uses the existing terminology.
Perhaps better is to not use <code>try_push</code>
and instead use <code>nonwaiting_push</code> and <code>nonblocking_push</code>.
</p>

<p>
<strong>In November 2016,
the Concurrency Study Group chose to defer non-blocking operations.
Hence, the proposed wording does not include these functions.
In addition,
as these functions were the only ones that returned <code>busy</code>,
that enumeration is also not included.</strong>
</p>


<h3><a name="push_front">Push Front Operations</a></h3>

<p>
Occasionally, one may wish to return a popped item to the queue.
We can provide for this with <code>push_front</code> operations.
</p>

<dl>

<dt><code>void
<var>queue</var>::push_front(const <var>Element</var>&amp;);</code></dt>
<dt><code>void
<var>queue</var>::push_front(<var>Element</var>&amp;&amp;);</code></dt>
<dd>
<p>
Push the <code><var>Element</var></code> onto the back of the queue,
i.e. in at the end of the queue that is normally popped.
Return <code>queue_op_status::success</code>.
</p>
</dd>

<dt><code>queue_op_status
<var>queue</var>::try_push_front(const <var>Element</var>&amp;);</code></dt>
<dt><code>queue_op_status
<var>queue</var>::try_push_front(<var>Element</var>&amp;&amp;);</code></dt>
<dd>
<p>
If the queue was full, return <code>queue_op_status::full</code>.
Otherwise, push the <code><var>Element</var></code> onto the front of the queue,
i.e. in at the end of the queue that is normally popped.
Return <code>queue_op_status::success</code>.
</p>
</dd>

<dt><code>queue_op_status
<var>queue</var>::nonblocking_push_front(const <var>Element</var>&amp;);</code></dt>
<dt><code>queue_op_status
<var>queue</var>::nonblocking_push_front(<var>Element</var>&amp;&amp;);</code></dt>
<dd>
<p>
If the operation would block, return <code>queue_op_status::busy</code>. 
Otherwise, if the queue is full, return <code>queue_op_status::full</code>.
Otherwise, push the <code><var>Element</var></code> onto the front queue.
i.e. in at the end of the queue that is normally popped.
Return <code>queue_op_status::success</code>.
</p>
</dd>

</dl>

<p>
This feature was requested at the Spring 2012 meeting.
However, we do not think the feature works.
</p>

<ul>

<li><p>
The name <code>push_front</code> is inconsistent
with existing "push back" nomenclature.
</p></li>

<li><p>
The effects of <code>push_front</code>
are only distinguishable from a regular push
when there is a strong ordering of elements.
Highly concurrent queues will likely have no strong ordering.
</p></li>

<li><p>
The <code>push_front</code> call may fail
due to full queues, closed queues, etc.
In which case the operation will suffer contention,
and may succeed only after interposing push and pop operations.
The consequence is that
the original push order is not preserved in the final pop order.
So, <code>push_front</code> cannot be directly used as an 'undo'.
</p></li>

<li><p>
The operation implies an ability
to reverse internal changes at the front of the queue.
This ability implies a loss efficiency in some implementations.
</p></li>

</ul>

<p>
In short, we do not think that in a concurrent environment
<code>push_front</code> provides sufficient semantic value
to justify its cost.
Consequently, the proposed wording does not provide this feature.
</p>


<h3><a name="queue_names">Queue Names</a></h3>

<p>
It is sometimes desirable for queues to be able to identify themselves.
This feature is particularly helpful for run-time diagnotics,
particularly when 'ends' become dynamically passed around between threads.
See <a href="#Managed">Managed Indirection</a>.
</p>

<dl>
<dt><code>const char* <var>queue</var>::name();</code></dt>
<dd>
<p>
Return the name string provided as a parameter to queue construction.
</p>
</dd>
</dl>

<p>
There is some debate on this facility,
but we see no way to effectively replicate the facility.
However, in recognition of that debate,
the wording does not provide the name facility.
</p>


<h3><a name="lock_free_buffer_queue">Lock-Free Buffer Queue</a></h3>

<p>
We provide a concrete concurrent queue
in the form of a fixed-size <code>lock_free_buffer_queue</code>.
It meets the <code>NonWaitingConcurrentQueue</code> concept.
The queue is still under development,
so details may change.
</p>

<p>
<strong>In November 2016,
the Concurrency Study Group chose to defer lock-free queues.
Hence, the proposed wording does not include a concrete lock-free queue.
</strong>
</p>


<h3><a name="storage_iterators">Storage Iterators</a></h3>

<p>
In addition to iterators that stream data into and out of a queue,
we could provide an iterator over the storage contents of a queue.
Such and iterator, even when implementable,
would mostly likely be valid only when the queue is otherwise quiecent.
We believe such an iterator would be most useful for debugging,
which may well require knowledge of the concrete class.
Therefore, we do not propose wording for this feature.
</p>


<h3><a name="empty_full">Empty and Full Queues</a></h3>

<p>
It is sometimes desirable to know if a queue is empty.
</p>

<dl>
<dt><code>bool <var>queue</var>::is_empty() const noexcept;</code></dt>
<dd>
<p>
Return true iff the queue is empty.
</p>
</dd>
</dl>

<p>
This operation is useful only during intervals when
the queue is known to not be subject to pushes and pops
from other threads.
Its primary use case is assertions on the state of the queue
at the end if its lifetime,
or when the system is in quiescent state (where there no outstanding pushes).
</p>

<p>
We can imagine occasional use for knowing when a queue is full,
for instance in system performance polling.
The motivation is significantly weaker though.
</p>

<dl>
<dt><code>bool <var>queue</var>::is_full() const noexcept;</code></dt>
<dd>
<p>
Return true iff the queue is full.
</p>
</dd>
</dl>

<p>
Not all queues will have a full state,
and these would always return false.
</p>


<h3><a name="queue_order">Queue Ordering</a></h3>

<p>
The conceptual queue interface makes minimal guarantees.
</p>

<ul>

<li><p>
The queue is not empty if there is an element
that has been pushed but not popped.
</p></li>

<li><p>
A push operation <em>synchronizes with</em>
the pop operation that obtains that element.
</p></li>

<li><p>
A close operation <em>synchronizes with</em>
an operation that observes that the queue is closed.
</p></li>

<li><p>
There is a sequentially consistent order of operations.
</p></li>

</ul>

<p>
In particular, the conceptual interface does not guarantee
that the sequentially consistent order of element pushes
matches the sequentially consistent order of pops.
Concrete queues could specify more specific ordering guarantees.
</p>


<h3><a name="lock_free">Lock-Free Implementations</a></h3>

<p>
Lock-free queues will have some trouble
waiting for the queue to be non-empty or non-full.
Therefore, we propose two closely-related concepts.
A full concurrent queue concept as described above,
and a non-waiting concurrent queue concept
that has all the operations except
<code>push</code>, <code>wait_push</code>,
<code>value_pop</code> and <code>wait_pop</code>.
That is, it has only non-waiting operations
(presumably emulated with busy wait)
and non-blocking operations,
but no waiting operations.
We propose naming these <code>WaitingConcurrentQueue</code>
and <code>NonWaitingConcurrentQueue</code>,
respectively.
</p>

<p>
Note: Adopting this conceptual split
requires splitting some of the facilities defined later.
</p>

<p>
For generic code it's sometimes important to know if  a concurrent queue
has a lock free implementation.

</p><dl>
<dt><code>constexpr static bool <var>queue</var>::is_always_lock_free() noexcept;</code></dt>
<dd>
<p>
Return true iff the has a lock-free implementation
of the non-waiting operations.
</p>
</dd>
</dl>


<h2><a name="Tools">Abandoned Additional Conceptual Tools</a></h2>

<p>
There are a number of tools that support use of the conceptual interface.
These tools are not part of the queue interface,
but provide restricted views or adapters on top of the queue
useful in implementing concurrent algorithms.
</p>


<h3><a name="front_back">Fronts and Backs</a></h3>

<p>
Restricting an interface to one side of a queue
is a valuable code structuring tool.
This restriction is accomplished with
the classes <code>generic_queue_front</code>
and <code>generic_queue_back</code>
parameterized on the concrete queue implementation.
These act as pointers
with access to only the front or the back of a queue.
The front of the queue is where elements are popped.
The back of the queue is where elements are pushed.
</p>

<pre class="example"><code>void send( int number, generic_queue_back&lt;buffer_queue&lt;int&gt;&gt; arv );</code>
</pre>

<p>
These fronts and backs
are also able to provide <code>begin</code> and <code>end</code> operations
that unambiguously stream data into or out of a queue.
</p>


<h3><a name="streaming_iterators">Streaming Iterators</a></h3>

<p>
In order to enable the use of existing algorithms
streaming through concurrent queues,
they need to support iterators.
Output iterators will push to a queue
and input iterators will pop from a queue.
Stronger forms of iterators
are in general not possible with concurrent queues.
</p>

<p>
Iterators implicitly require waiting for the advance,
so iterators are only supportable
with the <code>WaitingConcurrentQueue</code> concept.
</p>

<pre class="example"><code>void iterate(
    generic_queue_back&lt;buffer_queue&lt;int&gt;&gt;::iterator bitr,
    generic_queue_back&lt;buffer_queue&lt;int&gt;&gt;::iterator bend,
    generic_queue_front&lt;buffer_queue&lt;int&gt;&gt;::iterator fitr,
    generic_queue_front&lt;buffer_queue&lt;int&gt;&gt;::iterator fend,
    int (*compute)( int ) )
{
    while ( fitr != fend &amp;&amp; bitr != bend )
        *bitr++ = compute(*fitr++);
}</code>
</pre>

<p>
Note that contrary to existing iterator algorithms,
we check both iterators for reaching their end,
as either may be closed at any time.
</p>

<p>
Note that with suitable renaming,
the existing standard front insert and back insert iterators could work as is.
However, there is nothing like a pop iterator adapter.
</p>


<h3><a name="Binary">Binary Interfaces</a></h3>

<p>
The standard library is template based,
but it is often desirable to have a binary interface
that shields client from the concrete implementations.
For example, <code>std::function</code> is a binary interface
to callable object (of a given signature).
We achieve this capability in queues with type erasure.
</p>

<p>
We provide a <code>queue_base</code> class template
parameterized by the value type.
Its operations are virtual.
This class provides the essential independence
from the queue representation.
</p>

<p>
We also provide <code>queue_front</code> and <code>queue_back</code>
class templates parameterized by the value types.
These are essentially
<code>generic_queue_front&lt;queue_base&lt;Value&gt;&gt;</code> and
<code>generic_queue_front&lt;queue_base&lt;Value&gt;&gt;</code>,
respectively.
</p>

<p>
To obtain a pointer to <code>queue_base</code>
from an non-virtual concurrent queue,
construct an instance the <code>queue_wrapper</code> class template,
which is parameterized on the queue
and derived from <code>queue_base</code>.
Upcasting a pointer to the <code>queue_wrapper</code> instance
to a <code>queue_base</code> instance
thus erases the concrete queue type.
</p>

<pre class="example"><code>extern void seq_fill( int count, queue_back&lt;int&gt; b );

buffer_queue&lt;int&gt; body( 10 /*elements*/, /*named*/ "body" );
queue_wrapper&lt;buffer_queue&lt;int&gt;&gt; wrap( body );
seq_fill( 10, wrap.back() );</code>
</pre>


<h3><a name="Managed">Managed Indirection</a></h3>

<p>
Long running servers may have the need to
reconfigure the relationship between queues and threads.
The ability to pass 'ends' of queues between threads
with automatic memory management eases programming.
</p>

<p>
To this end, we provide
<code>shared_queue_front</code> and
<code>shared_queue_back</code> template classes.
These act as reference-counted versions
of the <code>queue_front</code> and
<code>queue_back</code> template classes.
</p>

<p>
The <code>share_queue_ends(Args ... args)</code> template function
will provide a pair of
<code>shared_queue_front</code> and <code>shared_queue_back</code>
to a dynamically allocated <code>queue_object</code> instance
containing an instance of the specified implementation queue.
When the last of these fronts and backs are deleted,
the queue itself will be deleted.
Also, when the last of the fronts or the last of the backs is deleted,
the queue will be closed.
</p>

<pre class="example"><code>auto x = share_queue_ends&lt;buffer_queue&lt;int&gt;&gt;( 10, "shared" );
shared_queue_back&lt;int&gt; b(x.back);
shared_queue_front&lt;int&gt; f(x.front);
f.push(3);
assert(3 == b.value_pop());</code>
</pre>


</body></html>
