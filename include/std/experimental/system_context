// Copyright (c) 2023 Gor Nishanov
// Licensed under MIT license. See LICENSE.txt for details.

#ifndef _STD_EXPERIMENTAL_SYSTEM_CONTEXT
#define _STD_EXPERIMENTAL_SYSTEM_CONTEXT

#include <dispatch/dispatch.h> // TODO: move it in platform specific code.
#include <exec/timed_scheduler.hpp>
#include <std/experimental/__detail/safe_nanosecond_cast.hpp>
#include <stdexec/execution.hpp>

#include <chrono>
#include <exception>

namespace std::experimental {

class system_context {
public:
  system_context() {}
  ~system_context() = default;

  system_context(const system_context&) = delete;
  system_context(system_context&&) = delete;
  system_context& operator=(const system_context&) = delete;
  system_context& operator=(system_context&&) = delete;

  class scheduler;
  scheduler get_scheduler();
  // size_t max_concurrency() const noexcept;
};

class system_context::scheduler {
  system_context& ctx;
  scheduler(system_context& ctx) : ctx(ctx) {}
  friend system_context;

public:
  ~scheduler() = default;

  scheduler(const scheduler& rhs) noexcept : ctx(rhs.ctx) {}
  scheduler(scheduler&& rhs) noexcept : ctx(rhs.ctx) {}
  scheduler& operator=(const scheduler&) = delete;
  scheduler& operator=(scheduler&&) = delete;

  bool operator==(const scheduler& rhs) const noexcept {
    return &ctx == &rhs.ctx;
  }

  class sender {
    system_context& ctx;
    sender(system_context& ctx) : ctx(ctx) {}

    friend scheduler;

  public:
    using is_sender = void;
    using completion_signatures =
        stdexec::completion_signatures<stdexec::set_value_t(),
                                       stdexec::set_error_t(std::exception_ptr),
                                       stdexec::set_stopped_t()>;

    struct env {
      system_context& ctx;

      template <class CPO>
      friend scheduler tag_invoke(stdexec::get_completion_scheduler_t<CPO>,
                                  const env& self) noexcept {
        return self.ctx.get_scheduler();
      }
    };

    friend env tag_invoke(stdexec::get_env_t, const sender& self) noexcept {
      return env{self.ctx};
    }

    template <typename Receiver> struct operation {
      Receiver receiver;

      operation(Receiver&& receiver) : receiver(std::move(receiver)) {}

      static void callback(void* context) noexcept {
        auto& op = *static_cast<operation*>(context);
        try {
          auto stop_token =
              stdexec::get_stop_token(stdexec::get_env(op.receiver));
          if constexpr (std::unstoppable_token<decltype(stop_token)>) {
            stdexec::set_value((Receiver&&)op.receiver);
          } else if (stop_token.stop_requested()) {
            stdexec::set_stopped((Receiver&&)op.receiver);
          } else {
            stdexec::set_value((Receiver&&)op.receiver);
          }
        } catch (...) {
          stdexec::set_error((Receiver&&)op.receiver, std::current_exception());
        }
      }

      friend void tag_invoke(stdexec::start_t, operation& op) noexcept {
        dispatch_async_f(
            dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), &op,
            &callback);
      }
    };

    template <stdexec::receiver Receiver>
    friend auto tag_invoke(stdexec::connect_t, sender&& s,
                           Receiver&& r) noexcept -> operation<Receiver> {
      return {std::forward<Receiver>(r)};
    }
  };
  friend sender tag_invoke(stdexec::schedule_t,
                           const scheduler& sched) noexcept {
    return {sched.ctx};
  }

  class schedule_after_sender {
    system_context& ctx;
    chrono::nanoseconds ns;
    schedule_after_sender(system_context& ctx, chrono::nanoseconds ns)
        : ctx(ctx), ns(ns) {}

    friend scheduler;

  public:
    using is_sender = void;
    using completion_signatures =
        stdexec::completion_signatures<stdexec::set_value_t(),
                                       stdexec::set_error_t(std::exception_ptr),
                                       stdexec::set_stopped_t()>;

    struct env {
      system_context& ctx;

      template <class CPO>
      friend scheduler tag_invoke(stdexec::get_completion_scheduler_t<CPO>,
                                  const env& self) noexcept {
        return self.ctx.get_scheduler();
      }
    };

    friend env tag_invoke(stdexec::get_env_t,
                          const schedule_after_sender& self) noexcept {
      return env{self.ctx};
    }
    template <typename Receiver> struct operation {
      Receiver receiver;
      chrono::nanoseconds ns;
      dispatch_source_t timer;

      operation(Receiver&& receiver, chrono::nanoseconds ns)
          : receiver(std::move(receiver)), ns(ns),
            timer(dispatch_source_create(
                DISPATCH_SOURCE_TYPE_TIMER, 0, 0,
                dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,
                                          0))) {
        assert(timer);
      }

      ~operation() { dispatch_release(timer); }

      static void callback(void* context) noexcept {
        auto& op = *static_cast<operation*>(context);
        try {
          auto stop_token =
              stdexec::get_stop_token(stdexec::get_env(op.receiver));
          if constexpr (std::unstoppable_token<decltype(stop_token)>) {
            stdexec::set_value((Receiver&&)op.receiver);
          } else if (stop_token.stop_requested()) {
            stdexec::set_stopped((Receiver&&)op.receiver);
          } else {
            stdexec::set_value((Receiver&&)op.receiver);
          }
        } catch (...) {
          stdexec::set_error((Receiver&&)op.receiver, std::current_exception());
        }
      }

      static void cancel_callback(void* context) noexcept {
        auto& op = *static_cast<operation*>(context);
        stdexec::set_stopped((Receiver&&)op.receiver);
      }

      friend void tag_invoke(stdexec::start_t, operation& op) noexcept {
        dispatch_set_context(op.timer, &op);
        dispatch_source_set_event_handler_f(op.timer, &callback);
        dispatch_source_set_cancel_handler_f(op.timer, &cancel_callback);
        dispatch_source_set_timer(op.timer, DISPATCH_TIME_NOW, op.ns.count(),
                                  0);
        dispatch_resume(op.timer);
      }
    };

    template <stdexec::receiver Receiver>
    friend auto tag_invoke(stdexec::connect_t, schedule_after_sender&& s,
                           Receiver&& r) noexcept -> operation<Receiver> {
      return {std::forward<Receiver>(r), s.ns};
    }
  };

  template <typename Rep, typename Ratio>
  schedule_after_sender
  schedule_after(std::chrono::duration<Rep, Ratio> delay) const noexcept {
    return schedule_after_sender{ctx, __detail::safe_nanosecond_cast(delay)};
  }

  template <typename Clock, typename Duration>
  auto schedule_at(
      const chrono::time_point<Clock, Duration>& dueTime) const noexcept {
    return schedule_after(dueTime - Clock::now());
  }

  template <class _Clock, class _Duration>
  friend auto
  tag_invoke(exec::schedule_at_t, const scheduler& sched,
             const std::chrono::time_point<_Clock, _Duration>& at) noexcept {
    return sched.schedule_at(at);
  }

  template <typename Rep, typename Ratio>
  friend auto
  tag_invoke(exec::schedule_after_t, const scheduler& sched,
             const std::chrono::duration<Rep, Ratio> delay) noexcept {
    return sched.schedule_after(delay);
  }

  friend stdexec::forward_progress_guarantee
  tag_invoke(stdexec::get_forward_progress_guarantee_t,
             const scheduler&) noexcept {
    return stdexec::forward_progress_guarantee::parallel;
  }
  class bulk_sender;
  template <typename Sh, typename F>
  friend bulk_sender tag_invoke(stdexec::bulk_t, const scheduler&, Sh&& sh,
                                F&& f) noexcept;
};

inline system_context::scheduler system_context::get_scheduler() {
  return {*this};
}

} // namespace std::experimental

#endif // _STD_EXPERIMENTAL_SYSTEM_CONTEXT
