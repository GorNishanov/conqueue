// Copyright (c) 2023 Gor Nishanov
// Licenced under MIT license. See LICENSE.txt for details.

#ifndef _STD_EXPERIMENTAL_CONQUEUE
#define _STD_EXPERIMENTAL_CONQUEUE
#include <atomic>
#include <cstdio>
#include <deque>
#include <mutex>
#include <optional>
#include <stdio.h>
#include <system_error>
#include <variant>

#include <stdexec/__detail/__intrusive_queue.hpp>
#include <stdexec/execution.hpp>

#include "exec/inline_scheduler.hpp"
#include <exec/__detail/__manual_lifetime.hpp>

namespace std::experimental {
enum class conqueue_errc { empty = 1, full, closed };
}

namespace std {
template <>
struct is_error_code_enum<experimental::conqueue_errc> : public true_type {};
} // namespace std

namespace std::experimental {

error_code make_error_code(conqueue_errc e) noexcept;
error_condition make_error_condition(conqueue_errc e) noexcept;

const error_category &conqueue_category() noexcept;

class conqueue_error : public logic_error {
public:
  conqueue_error(error_code ec);
  explicit conqueue_error(conqueue_errc);
  const error_code &code() const noexcept;
  const char *what() const noexcept;
};

// Inspired by https://wg21.link/P0260R5 A proposal to add a concurrent queue to
// the standard library and https://wg21.link/p1958 A proposal to add a
// concurrent queue to the standard library

template <typename T> class buffer_queue {
  buffer_queue() = delete;
  buffer_queue(const buffer_queue &) = delete;
  buffer_queue &operator=(const buffer_queue &) = delete;

  struct pop_sender;
  struct push_sender;

  struct waiter_base {
    waiter_base *next{};
    T *value_ptr{};
    void (*__complete)(waiter_base *) noexcept;
  };

  struct sync_waiter : waiter_base {
    std::atomic_flag flag;

    sync_waiter(T &x) noexcept {
      this->value_ptr = std::addressof(x);
      this->__complete = [](waiter_base *w) noexcept {
        auto *self = static_cast<sync_waiter *>(w);
        printf("notifying sync waiter %p\n", w);
        self->flag.test_and_set();
        self->flag.notify_one();
      };
    }

    void wait() noexcept { flag.wait(false); }
  };

public:
  typedef T value_type;
  explicit buffer_queue(size_t max_elems);
  template <typename Iter>
  buffer_queue(size_t max_elems, Iter first, Iter last);
  ~buffer_queue() noexcept;

  void close() noexcept;

  T pop();
  std::optional<T> pop(std::error_code &ec);
  std::optional<T> try_pop();
  std::optional<T> try_pop(T &, std::error_code &ec);

  pop_sender async_pop() noexcept;

  // For expediency push(T&&) and push(T const&) were collapsed into
  // push(T). Later we can split them up.

  void push(T x);
  push_sender async_push(T x);
  bool try_push(const T &x);
  bool try_push(const T &x, std::error_code &ec);

private:
  std::mutex mutex;
  size_t limit;
  std::deque<T> queue; // TODO: replace with a fixed size circular buffer.
  // If the queue is empty, waiters are the readers.
  // If the queue is full, waiters are the writers.
  stdexec::__intrusive_queue<&waiter_base::next> waiters;
};

// Implementation

template <typename T>
buffer_queue<T>::buffer_queue(size_t max_elems) : limit(max_elems) {}

template <typename T> buffer_queue<T>::~buffer_queue() noexcept { close(); }

template <typename T> void buffer_queue<T>::close() noexcept {
  // TODO: Complete all pending operations with error closed.
}

template <typename T> void buffer_queue<T>::push(T x) {
  std::unique_lock lock(mutex);
  if (limit == 0) {
    sync_waiter waiter(x);
    waiters.push_back(&waiter);
    lock.unlock();
    return waiter.wait(); // TODO: Check queue closed error and throw.
  }
  // See if there are any waiters, if so, pass the value directly to them.
  if (!waiters.empty()) {
    auto *waiter = waiters.pop_front();
    *waiter->value_ptr = std::move(x); // TODO: Mess with __manual_lifetime.
    lock.unlock();
    waiter->__complete(waiter);
    return;
  }
  queue.push_back(std::move(x));
  --limit;
}

template <typename T> struct buffer_queue<T>::push_sender {
  buffer_queue *queue;
  T value;

  using is_sender = void;
  using completion_signatures =
      stdexec::completion_signatures<stdexec::set_value_t()>;

  struct __env {

    friend exec::inline_scheduler
    tag_invoke(stdexec::get_completion_scheduler_t<stdexec::set_value_t>,
               const __env &) //
        noexcept {
      return {};
    }
  };

  friend __env tag_invoke(stdexec::get_env_t, const push_sender &) noexcept {
    return {};
  }

  template <typename Receiver> struct operation : waiter_base {
    push_sender sender;
    Receiver receiver;

    operation(push_sender &&sender, Receiver &&receiver)
        : sender(std::move(sender)), receiver(std::move(receiver)) {
      this->value_ptr = std::addressof(sender.value);
      this->__complete = [](waiter_base *w) noexcept {
        auto *self = static_cast<operation *>(w);
        stdexec::set_value((Receiver &&)self->receiver);
      };
    }

    friend void tag_invoke(stdexec::start_t, operation &op) noexcept {
      auto &self = *op.sender.queue;
      std::unique_lock lock(self.mutex);
      if (self.limit == 0) {
        printf("async_push: queue is full, putting %p in the waiters queue\n",
               &op);
        self.waiters.push_back(&op);
        return;
      }
      // See if there are any waiters, if so, pass the value directly to them.
      if (!self.waiters.empty()) {
        auto *waiter = self.waiters.pop_front();
        *waiter->value_ptr =
            std::move(op.sender.value); // TODO: Mess with __manual_lifetime.
        lock.unlock();
        printf("async push: unlocking reader %p\n", waiter);
        waiter->__complete(waiter);
      } else {
        printf("async push: queue is not full, pushing value %d\n",
               op.sender.value);
        self.queue.push_back(std::move(op.sender.value));
        ++self.limit;
      }
      stdexec::set_value((Receiver &&)op.receiver);
    }
  };

  template <stdexec::receiver Receiver>
  friend auto tag_invoke(stdexec::connect_t, push_sender &&s, Receiver &&r)
      -> operation<Receiver> {
    return {std::move(s), std::forward<Receiver>(r)};
  }
};

template <typename T>
buffer_queue<T>::push_sender buffer_queue<T>::async_push(T x) {
  return {this, std::move(x)};
}

template <typename T> T buffer_queue<T>::pop() {
  T result; // TODO: mess with __manual_lifetime
  std::unique_lock lock(mutex);

  // If the queue is empty, wait for a value to be pushed.
  if (queue.empty()) {
    sync_waiter waiter(result);
    printf("pull: queue is empty, putting %p in the waiters queue\n", &waiter);
    waiters.push_back(&waiter);
    lock.unlock();
    waiter.wait(); // TODO: Check for queue closed error and throw.
    printf("pull: %p was just resumed\n", &waiter);
    return result;
  }
  result = std::move(queue.front());
  queue.pop_front();

  // See if there are any waiters
  if (!waiters.empty()) {
    auto *waiter = waiters.pop_front();
    queue.push_back(std::move(*waiter->value_ptr));
    lock.unlock();
    printf("unlocking pusher %p\n", waiter);
    waiter->__complete(waiter);
    return result;
  }

  ++limit;
  return result;
}

template <typename T> struct buffer_queue<T>::pop_sender {
  buffer_queue *queue;

  using is_sender = void;
  using completion_signatures =
      stdexec::completion_signatures<stdexec::set_value_t(T)>;

  struct __env {

    friend exec::inline_scheduler
    tag_invoke(stdexec::get_completion_scheduler_t<stdexec::set_value_t>,
               const __env &) //
        noexcept {
      return {};
    }
  };

  friend __env tag_invoke(stdexec::get_env_t, const pop_sender &) noexcept {
    return {};
  }

  template <typename Receiver> struct operation : waiter_base {
    buffer_queue &queue;
    Receiver receiver;
    T value;

    operation(buffer_queue &queue, Receiver &&receiver)
        : queue(queue), receiver(std::move(receiver)) {
      this->value_ptr = std::addressof(value);
      this->__complete = [](waiter_base *w) noexcept {
        auto *self = static_cast<operation *>(w);
        stdexec::set_value((Receiver &&)self->receiver, std::move(self->value));
      };
    }

    friend void tag_invoke(stdexec::start_t, operation &op) noexcept {
      auto &self = op.queue;
      std::unique_lock lock(self.mutex);
      // If the queue is empty, add ourselves to the waiters.
      if (self.queue.empty()) {
        printf("async_pop: queue is empty, putting %p in the waiters queue\n",
               &op);
        self.waiters.push_back(&op);
        return;
      }

      op.value = std::move(self.queue.front());
      self.queue.pop_front();

      // See if there are any waiters
      if (!self.waiters.empty()) {
        auto *waiter = self.waiters.pop_front();
        self.queue.push_back(std::move(*waiter->value_ptr));
        lock.unlock();
        printf("async_pop: unlocking pusher %p\n", waiter);
        waiter->__complete(waiter);
      } else {
        ++self.limit;
        lock.unlock();
      }

      stdexec::set_value((Receiver &&)op.receiver, std::move(op.value));
    }
  };

  template <stdexec::receiver Receiver>
  friend auto tag_invoke(stdexec::connect_t, pop_sender &&s, Receiver &&r)
      -> operation<Receiver> {
    return {*s.queue, std::forward<Receiver>(r)};
  }
};

template <typename T>
buffer_queue<T>::pop_sender buffer_queue<T>::async_pop() noexcept {
  return {this};
}

} // namespace std::experimental

#endif // _STD_EXPERIMENTAL_CONQUEUE
