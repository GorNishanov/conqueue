// Copyright (c) 2023 Gor Nishanov
// Licenced under MIT license. See LICENSE.txt for details.

#ifndef _STD_EXPERIMENTAL_CONQUEUE
#define _STD_EXPERIMENTAL_CONQUEUE
#include "__detail/tracing.hpp"

#include <atomic>
#include <deque>
#include <exception>
#include <mutex>
#include <optional>
#include <stdio.h>
#include <system_error>
#include <variant>

#include <stdexec/__detail/__intrusive_queue.hpp>
#include <stdexec/execution.hpp>

namespace std::experimental {
enum class conqueue_errc { success, empty, full, closed };
}

namespace std {
template <>
struct is_error_code_enum<experimental::conqueue_errc> : public true_type {};
} // namespace std

namespace std::experimental {

const error_category& conqueue_category() noexcept;

inline error_code make_error_code(conqueue_errc e) noexcept {
  return {static_cast<int>(e), conqueue_category()};
}

inline error_condition make_error_condition(conqueue_errc e) noexcept {
  return {static_cast<int>(e), conqueue_category()};
}

class conqueue_error : public runtime_error {
  error_code ec;

public:
  explicit conqueue_error(const std::error_code& ec);
  ~conqueue_error() noexcept;

  const error_code& code() const noexcept { return ec; }
};

// Inspired by https://wg21.link/P0260R5 A proposal to add a concurrent queue
// to the standard library and https://wg21.link/p1958 A proposal to add a
// concurrent queue to the standard library

template <typename T> class buffer_queue {
  buffer_queue() = delete;
  buffer_queue(const buffer_queue&) = delete;
  buffer_queue& operator=(const buffer_queue&) = delete;

  struct pop_sender;
  struct push_sender;

  struct waiter_base {
    waiter_base* next{};
    // For push case, we store the pointer to the value to be pushed.
    // For pop case, we store the value.
    variant<monostate, conqueue_errc, T, T*> value;
    void (*complete)(waiter_base*) noexcept;

    T& get_value() noexcept {
      // pre: user already verified that the value does not contain the error.
      // pre: by construction, it should not be a monostate by the point we get
      // here.
      if (T* v = get_if<T>(&value))
        return *v;
      else
        return *std::get<T*>(value);
    }

    ~waiter_base() noexcept {
      STDEX_CONQUEUE_LOG("waiter_base: destroying %p\n", this);
    }
  };

  struct blocking_waiter;

  std::optional<T> locked_pop(unique_lock<mutex>& lock, error_code& ec);
  bool locked_push(unique_lock<mutex>& lock, T& value, error_code& ec);

public:
  typedef T value_type;
  explicit buffer_queue(size_t max_elems);
  template <typename Iter>
  buffer_queue(size_t max_elems, Iter first, Iter last);
  ~buffer_queue() noexcept;

  // observers
  bool is_closed() noexcept { return closed; }

  // modifiers
  void close() noexcept;

  pop_sender async_pop() noexcept;
  T pop();
  std::optional<T> pop(std::error_code& ec);
  std::optional<T> try_pop(std::error_code& ec);

  // For expediency push(T&&) and push(T const&) were collapsed into
  // push(T). Real implementation can split them up.

  push_sender async_push(T x) noexcept(is_nothrow_move_constructible_v<T>);
  void push(T x);
  bool push(T x, error_code& ec);
  bool try_push(T x, error_code& ec);

private:
  std::mutex mutex;
  size_t limit;
  bool closed{};
  std::deque<T> queue; // TODO: replace with a fixed size circular buffer.
  // If the queue is empty, waiters are the readers.
  // If the queue is full, waiters are the writers.
  stdexec::__intrusive_queue<&waiter_base::next> waiters;
};

// Implementation

template <typename T>
buffer_queue<T>::buffer_queue(size_t max_elems) : limit(max_elems) {}

template <typename T> buffer_queue<T>::~buffer_queue() noexcept { close(); }

template <typename T> void buffer_queue<T>::close() noexcept {
  std::unique_lock lock(mutex);
  if (closed)
    return;
  closed = true;
  while (!waiters.empty()) {
    auto* waiter = waiters.pop_front();
    waiter->value = conqueue_errc::closed;
    lock.unlock();
    waiter->complete(waiter);
    lock.lock();
  }
}

template <typename T>
bool buffer_queue<T>::locked_push(unique_lock<std::mutex>& lock, T& value,
                                  error_code& ec) {
  // The caller acquired the lock and verified that the queue is not full.
  ec = {};

  // See if there are any waiters, if so, pass the value directly to them.
  if (!waiters.empty()) {
    auto* waiter = waiters.pop_front();
    waiter->value = std::move(value);
    lock.unlock();
    waiter->complete(waiter);
    return true;
  }

  queue.push_back(std::move(value));
  --limit;
  return true;
}

template <typename T> bool buffer_queue<T>::try_push(T x, error_code& ec) {
  std::unique_lock lock(mutex);
  if (closed) {
    ec = conqueue_errc::closed;
    return false;
  }

  if (limit == 0) {
    ec = conqueue_errc::full;
    return false;
  }

  return locked_push(lock, x, ec);
}

template <typename T> struct buffer_queue<T>::blocking_waiter : waiter_base {
  std::atomic_flag flag;

  blocking_waiter() noexcept {
    this->complete = [](waiter_base* w) noexcept {
      auto* self = static_cast<blocking_waiter*>(w);
      STDEX_CONQUEUE_LOG("notifying sync waiter %p\n", w);
      self->flag.test_and_set();
      self->flag.notify_one();
    };
  }

  blocking_waiter(T& x) noexcept : blocking_waiter() {
    this->value = std::addressof(x);
  }

  void wait() noexcept { flag.wait(false); }
};

template <typename T> bool buffer_queue<T>::push(T x, error_code& ec) {
  std::unique_lock lock(mutex);
  if (closed) {
    ec = conqueue_errc::closed;
    return false;
  }

  if (limit == 0) {
    blocking_waiter waiter(x);
    STDEX_CONQUEUE_LOG("push: queue is full, putting %p in the waiters queue\n",
                       &waiter);
    waiters.push_back(&waiter);
    lock.unlock();
    waiter.wait();
    STDEX_CONQUEUE_LOG("push: was resumed %p\n", &waiter);
    // Queue got closed while we were waiting.
    if (auto* errc = get_if<conqueue_errc>(&waiter.value)) {
      ec = *errc;
      return false;
    }
    ec = {};
    return true;
  }

  return locked_push(lock, x, ec);
}

template <typename T> void buffer_queue<T>::push(T x) {
  error_code ec;
  if (!push(std::move(x), ec))
    throw conqueue_error(ec);
}

template <typename T> struct buffer_queue<T>::push_sender {
  buffer_queue* queue;
  T value;

  using is_sender = void;
  using completion_signatures = // TODO: Cancellation support.
      stdexec::completion_signatures<stdexec::set_value_t(),
                                     stdexec::set_error_t(std::exception_ptr),
                                     stdexec::set_stopped_t()>;

  template <typename Receiver> struct operation : waiter_base {
    push_sender sender;
    Receiver receiver;

    operation(push_sender&& sender, Receiver&& receiver)
        : sender(std::move(sender)), receiver(std::move(receiver)) {
      this->value = std::addressof(sender.value);
      this->complete = [](waiter_base* w) noexcept {
        auto* self = static_cast<operation*>(w);
        if (auto* errc = get_if<conqueue_errc>(&self->value))
          stdexec::set_error((Receiver&&)self->receiver,
                             make_exception_ptr(conqueue_error(*errc)));
        else
          stdexec::set_value((Receiver&&)self->receiver);
      };
    }

    friend void tag_invoke(stdexec::start_t, operation& op) noexcept {
      auto& self = *op.sender.queue;
      std::unique_lock lock(self.mutex);
      if (self.closed) {
        lock.unlock();
        stdexec::set_error(
            (Receiver&&)op.receiver,
            make_exception_ptr(conqueue_error(conqueue_errc::closed)));
        return;
      }
      if (self.limit == 0) {
        STDEX_CONQUEUE_LOG(
            "async_push: queue is full, putting %p in the waiters queue\n",
            &op);
        self.waiters.push_back(&op);
        return;
      }
      // See if there are any waiters, if so, pass the value directly to them.
      if (!self.waiters.empty()) {
        auto* waiter = self.waiters.pop_front();
        waiter->value = &op.sender.value;
        lock.unlock();
        STDEX_CONQUEUE_LOG("async push: unlocking reader %p\n", waiter);
        waiter->complete(waiter);
      } else {
        STDEX_CONQUEUE_LOG("async push: queue is not full, pushing value %d\n",
                           op.sender.value);
        self.queue.push_back(std::move(op.sender.value));
        ++self.limit;
      }
      stdexec::set_value((Receiver&&)op.receiver);
    }
  };

  template <stdexec::receiver Receiver>
  friend auto tag_invoke(stdexec::connect_t, push_sender&& s, Receiver&& r)
      -> operation<Receiver> {
    return {std::move(s), std::forward<Receiver>(r)};
  }
};

template <typename T>
typename buffer_queue<T>::push_sender
buffer_queue<T>::async_push(T x) noexcept(is_nothrow_move_constructible_v<T>) {
  return {this, std::move(x)};
}

template <typename T>
optional<T> buffer_queue<T>::locked_pop(unique_lock<std::mutex>& lock,
                                        error_code& ec) {
  // The caller already verified that the queue is not empty.
  ec = {};
  T result = std::move(queue.front());
  queue.pop_front();

  // See if there are any waiters that can be resumed now.
  if (!waiters.empty()) {
    // During pop, waiters are the pushers blocked because the queue is full.
    // Release a single pusher and put its value into the queue.
    auto* waiter = waiters.pop_front();
    queue.push_back(std::move(waiter->get_value()));
    lock.unlock();
    STDEX_CONQUEUE_LOG("unlocking pusher %p\n", waiter);
    waiter->complete(waiter);
    return result;
  }

  ++limit;
  return result;
}

template <typename T>
optional<T> buffer_queue<T>::try_pop(std::error_code& ec) {
  std::unique_lock lock(mutex);

  // If the queue is empty, wait for a value to be pushed.
  if (queue.empty()) {
    ec = closed ? conqueue_errc::closed : conqueue_errc::empty;
    return nullopt;
  }

  return locked_pop(lock, ec);
}

template <typename T> optional<T> buffer_queue<T>::pop(error_code& ec) {
  std::unique_lock lock(mutex);

  // If the queue is empty, wait for a value to be pushed.
  if (queue.empty()) {
    // Unless, of course, the queue is closed, then return an error.
    if (closed) {
      ec = conqueue_errc::closed;
      return nullopt;
    }
    blocking_waiter waiter;
    STDEX_CONQUEUE_LOG("pop: queue is empty, putting %p in the waiters queue\n",
                       &waiter);
    waiters.push_back(&waiter);
    lock.unlock();
    waiter.wait();
    STDEX_CONQUEUE_LOG("pop: %p was just resumed\n", &waiter);
    if (auto* errc = get_if<conqueue_errc>(&waiter.value)) {
      ec = *errc;
      return nullopt;
    }
    ec = {};
    return waiter.get_value();
  }

  return locked_pop(lock, ec);
}

template <typename T> T buffer_queue<T>::pop() {
  std::error_code ec;
  if (auto result = pop(ec))
    return *result;

  throw conqueue_error(ec);
}

template <typename T> struct buffer_queue<T>::pop_sender {
  buffer_queue* queue;

  using is_sender = void;
  using completion_signatures = // TODO: Cancellation support.
      stdexec::completion_signatures<stdexec::set_value_t(T),
                                     stdexec::set_error_t(std::exception_ptr),
                                     stdexec::set_stopped_t()>;

  template <typename Receiver> struct operation : waiter_base {
    buffer_queue& queue;
    Receiver receiver;

    operation(buffer_queue& queue, Receiver&& receiver)
        : queue(queue), receiver(std::move(receiver)) {
      this->complete = [](waiter_base* w) noexcept {
        auto* self = static_cast<operation*>(w);
        if (auto* errc = get_if<conqueue_errc>(&self->value))
          stdexec::set_error((Receiver&&)self->receiver,
                             make_exception_ptr(conqueue_error(*errc)));
        else
          stdexec::set_value((Receiver&&)self->receiver,
                             std::move(self->get_value()));
      };
    }

    friend void tag_invoke(stdexec::start_t, operation& op) noexcept {
      auto& self = op.queue;
      std::unique_lock lock(self.mutex);
      // If the queue is empty, add ourselves to the waiters.
      if (self.queue.empty()) {
        // Unless, of course, the queue is closed, then return an error.
        if (self.closed) {
          lock.unlock();
          stdexec::set_error(
              (Receiver&&)op.receiver,
              make_exception_ptr(conqueue_error(conqueue_errc::closed)));
          return;
        }

        STDEX_CONQUEUE_LOG(
            "async_pop: queue is empty, putting %p in the waiters queue\n",
            &op);
        self.waiters.push_back(&op);
        return;
      }

      T value = std::move(self.queue.front());
      self.queue.pop_front();

      // See if there are any waiters
      if (!self.waiters.empty()) {
        // During pop, waiters are the pushers blocked because the queue is
        // full. Release a single pusher and put its value into the queue.
        auto* waiter = self.waiters.pop_front();
        self.queue.push_back(std::move(waiter->get_value()));
        lock.unlock();
        STDEX_CONQUEUE_LOG("async_pop: unlocking pusher %p\n", waiter);
        waiter->complete(waiter);
      } else {
        ++self.limit;
        lock.unlock();
      }

      stdexec::set_value((Receiver&&)op.receiver, std::move(value));
    }
  };

  template <stdexec::receiver Receiver>
  friend auto tag_invoke(stdexec::connect_t, pop_sender&& s, Receiver&& r)
      -> operation<Receiver> {
    return {*s.queue, std::forward<Receiver>(r)};
  }
};

template <typename T>
typename buffer_queue<T>::pop_sender buffer_queue<T>::async_pop() noexcept {
  return {this};
}
} // namespace std::experimental

#endif // _STD_EXPERIMENTAL_CONQUEUE
